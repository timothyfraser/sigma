<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>1 Statistical Techniques for Exponential Distributions | 07b_workshop_python.knit</title>
  <meta name="description" content="" />
  <meta name="generator" content="bookdown 0.45 and GitBook 2.6.7" />

  <meta property="og:title" content="1 Statistical Techniques for Exponential Distributions | 07b_workshop_python.knit" />
  <meta property="og:type" content="book" />
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1 Statistical Techniques for Exponential Distributions | 07b_workshop_python.knit" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  


<script src="assets/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="assets/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="assets/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="assets/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="assets/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="assets/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="assets/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="assets/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="assets/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="assets/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="assets/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

<link rel="stylesheet" href="styles.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path=""><a href="#statistical-techniques-for-exponential-distributions"><i class="fa fa-check"></i><b>1</b> Statistical Techniques for Exponential Distributions</a>
<ul>
<li class="chapter" data-level="1.1" data-path=""><a href="#getting-started"><i class="fa fa-check"></i><b>1.1</b> Getting Started</a>
<ul>
<li class="chapter" data-level="1.1.1" data-path=""><a href="#load-packages"><i class="fa fa-check"></i><b>1.1.1</b> Load Packages</a></li>
<li class="chapter" data-level="1.1.2" data-path=""><a href="#our-data"><i class="fa fa-check"></i><b>1.1.2</b> Our Data</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path=""><a href="#factors-in-python"><i class="fa fa-check"></i><b>1.2</b> Factors in Python</a></li>
<li class="chapter" data-level="1.3" data-path=""><a href="#crosstabulation"><i class="fa fa-check"></i><b>1.3</b> Crosstabulation</a></li>
<li class="chapter" data-level="" data-path=""><a href="#learning-check-1"><i class="fa fa-check"></i>Learning Check 1</a></li>
<li class="chapter" data-level="1.4" data-path=""><a href="#estimating-lambda"><i class="fa fa-check"></i><b>1.4</b> Estimating Lambda</a>
<ul>
<li class="chapter" data-level="1.4.1" data-path=""><a href="#lambda-from-complete-sample"><i class="fa fa-check"></i><b>1.4.1</b> Lambda from Complete Sample</a></li>
<li class="chapter" data-level="1.4.2" data-path=""><a href="#hatlambda-from-cross-tabulation"><i class="fa fa-check"></i><b>1.4.2</b> <span class="math inline">\(\hat{\lambda}\)</span> from Cross-Tabulation</a></li>
</ul></li>
<li class="chapter" data-level="" data-path=""><a href="#learning-check-2"><i class="fa fa-check"></i>Learning Check 2</a>
<ul>
<li class="chapter" data-level="1.4.3" data-path=""><a href="#confidence-intervals-for-hatlambda"><i class="fa fa-check"></i><b>1.4.3</b> Confidence Intervals for <span class="math inline">\(\hat{\lambda}\)</span></a></li>
</ul></li>
<li class="chapter" data-level="" data-path=""><a href="#learning-check-3"><i class="fa fa-check"></i>Learning Check 3</a></li>
<li class="chapter" data-level="1.5" data-path=""><a href="#planning-experiments"><i class="fa fa-check"></i><b>1.5</b> Planning Experiments</a>
<ul>
<li class="chapter" data-level="1.5.1" data-path=""><a href="#example-minimum-sample-size"><i class="fa fa-check"></i><b>1.5.1</b> Example: Minimum Sample Size</a></li>
</ul></li>
<li class="chapter" data-level="1.6" data-path=""><a href="#chi-squared"><i class="fa fa-check"></i><b>1.6</b> Chi-squared</a>
<ul>
<li class="chapter" data-level="1.6.1" data-path=""><a href="#compute-chi-squared-from-scratch"><i class="fa fa-check"></i><b>1.6.1</b> Compute Chi-squared from scratch</a></li>
<li class="chapter" data-level="1.6.2" data-path=""><a href="#building-a-chi-squared-function"><i class="fa fa-check"></i><b>1.6.2</b> Building a Chi-squared function</a></li>
</ul></li>
<li class="chapter" data-level="" data-path=""><a href="#learning-check-4"><i class="fa fa-check"></i>Learning Check 4</a></li>
<li class="chapter" data-level="1.7" data-path=""><a href="#conclusion"><i class="fa fa-check"></i><b>1.7</b> Conclusion</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./"></a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<!--bookdown:title:end-->
<!--bookdown:title:start-->
<div id="statistical-techniques-for-exponential-distributions" class="section level1 hasAnchor" number="1">
<h1><span class="header-section-number">1</span> Statistical Techniques for Exponential Distributions<a href="#statistical-techniques-for-exponential-distributions" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="getting-started" class="section level2 hasAnchor" number="1.1">
<h2><span class="header-section-number">1.1</span> Getting Started<a href="#getting-started" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>In this workshop, we’re going to examine several key tools that will help you (1) cross-tabulate failure data over time, (2) use statistics to determine whether an archetypal distribution (eg. exponential) fits your data sufficiently, (3) how to estimate the failure rate <span class="math inline">\(\lambda\)</span> from tabulated data, and (4) how to plan experiments for product testing. Here we go!</p>
<div id="load-packages" class="section level3 hasAnchor" number="1.1.1">
<h3><span class="header-section-number">1.1.1</span> Load Packages<a href="#load-packages" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Let’s start by loading the necessary Python packages. We’ll use <code>pandas</code> for data manipulation, <code>plotnine</code> for visualization, and <code>scipy.stats</code> for statistical functions.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># Load packages</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> chi2, expon, weibull_min</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="im">from</span> plotnine <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="im">import</span> os, sys</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>sys.path.append(os.path.abspath(<span class="st">&#39;functions&#39;</span>))</span></code></pre></div>
</div>
<div id="our-data" class="section level3 hasAnchor" number="1.1.2">
<h3><span class="header-section-number">1.1.2</span> Our Data<a href="#our-data" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In this workshop, we’re going to continue working with a data.frame called <code>masks</code>. Let’s examine a hypothetical sample of <code>n = 50</code> masks produced by Company X to measure how many hours it took for each part of the mask to break.</p>
<p>Please import the <code>masks.csv</code> DataFrame below. Each row is a mask, with its own unique <code>id</code>. Columns describe how many hours it took for the <code>left_earloop</code> to snap, the <code>right_earloop</code> to snap, the nose <code>wire</code> to snap, and the <code>fabric</code> of the mask to tear.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>masks <span class="op">=</span> pd.read_csv(<span class="st">&quot;workshops/masks.csv&quot;</span>)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="co"># Let&#39;s glimpse its contents!</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a><span class="co"># masks.info()</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>masks.head()</span></code></pre></div>
<pre><code>##    id  left_earloop  right_earloop  wire  fabric
## 0   1             6             12     4     177
## 1   2            16              1     1     462
## 2   3            46             17     8      65
## 3   4             4             14    29     405
## 4   5             1             19    23    2483</code></pre>
<p><br>
<br></p>
</div>
</div>
<div id="factors-in-python" class="section level2 hasAnchor" number="1.2">
<h2><span class="header-section-number">1.2</span> Factors in Python<a href="#factors-in-python" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>For the next section, you’ll need to understand categorical data in pandas.</p>
<ul>
<li><p>Categorical data in pandas is similar to factors in R. They are helpful for telling Python what order to interpret things in.</p></li>
<li><p>You can make your own Series into a categorical using <code>pd.Categorical(vector, categories = ["first", "second", "etc"], ordered=True)</code>.</p></li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="co"># Make character list</span></span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>myvector <span class="op">=</span> [<span class="st">&quot;surgical&quot;</span>, <span class="st">&quot;KN-95&quot;</span>, <span class="st">&quot;KN-95&quot;</span>, <span class="st">&quot;N-95&quot;</span>, <span class="st">&quot;surgical&quot;</span>]</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co"># Turn it into a factor (categorical)!</span></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>myfactor <span class="op">=</span> pd.Categorical(myvector, categories <span class="op">=</span> [<span class="st">&quot;N-95&quot;</span>, <span class="st">&quot;KN-95&quot;</span>, <span class="st">&quot;surgical&quot;</span>])</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a><span class="co"># check it</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>myfactor</span></code></pre></div>
<pre><code>## [&#39;surgical&#39;, &#39;KN-95&#39;, &#39;KN-95&#39;, &#39;N-95&#39;, &#39;surgical&#39;]
## Categories (3, object): [&#39;N-95&#39;, &#39;KN-95&#39;, &#39;surgical&#39;]</code></pre>
<p>Categorical data can be converted to numeric codes using <code>.codes</code>. This returns the level for each value in the factor.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="co"># Turn the categorical to numeric codes</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>mynum <span class="op">=</span> myfactor.codes</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co"># Compare</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>pd.DataFrame({<span class="st">&#39;myfactor&#39;</span>: myfactor, <span class="st">&#39;mynum&#39;</span>: mynum})</span></code></pre></div>
<pre><code>##    myfactor  mynum
## 0  surgical      2
## 1     KN-95      1
## 2     KN-95      1
## 3      N-95      0
## 4  surgical      2</code></pre>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="co"># for example, N-95, which was ranked first in the factor, receives a 0 (Python uses 0-based indexing)</span></span></code></pre></div>
<p><br>
<br></p>
</div>
<div id="crosstabulation" class="section level2 hasAnchor" number="1.3">
<h2><span class="header-section-number">1.3</span> Crosstabulation<a href="#crosstabulation" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Sometimes, we might want to tabulate failures in terms of meaningful units of time, counting the total failures every 5 hours, every 24 hours, etc. Let’s learn how!</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="co"># Take the left_earloop values and put them into a new DataFrame</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>d1 <span class="op">=</span> pd.DataFrame({</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>    <span class="st">&quot;t&quot;</span>: masks[<span class="st">&quot;left_earloop&quot;</span>]</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>})</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="co"># classify each value into 5-point width bins (0 to 5, 6-10, 11-15, etc.)</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a><span class="co"># then convert it to a numeric ranking of categories from 1  to n bins</span></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>d1[<span class="st">&quot;label&quot;</span>] <span class="op">=</span> pd.cut(</span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a>    d1[<span class="st">&quot;t&quot;</span>],</span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a>    bins <span class="op">=</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">int</span>(d1[<span class="st">&quot;t&quot;</span>].<span class="bu">max</span>()) <span class="op">+</span> <span class="dv">6</span>, <span class="dv">5</span>),    <span class="co"># creates 0–5, 5–10, ...</span></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a>)</span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a><span class="co"># Let&#39;s take a peek</span></span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a>d1.head()</span></code></pre></div>
<pre><code>##     t     label
## 0   6   (5, 10]
## 1  16  (15, 20]
## 2  46  (45, 50]
## 3   4    (0, 5]
## 4   1    (0, 5]</code></pre>
<p><strong>Step 2</strong>: Tabulate Observations per Bin.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="co"># Get total observed rows in each bin</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>d2 <span class="op">=</span> (</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>    d1</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>    <span class="co"># group by each interval/bin</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>    <span class="co"># dropna=False keeps empty categories</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>    .groupby(<span class="st">&quot;label&quot;</span>, dropna<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>    <span class="co"># count rows in each bin</span></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a>    .size()</span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>    <span class="co"># rename count column to r_obs</span></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>    .reset_index(name<span class="op">=</span><span class="st">&quot;r_obs&quot;</span>)</span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>)</span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a>d2.head()</span></code></pre></div>
<pre><code>##       label  r_obs
## 0    (0, 5]     17
## 1   (5, 10]     13
## 2  (10, 15]      3
## 3  (15, 20]      7
## 4  (20, 25]      2</code></pre>
<p><strong>Step 3</strong>: Get bounds and midpoint of Bins</p>
<p>Last, we might need the bounds (upper and lower value), or the midpoint. Here’s how!</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>d3 <span class="op">=</span> d2.copy()</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="co"># Get the bin numbers (1, 2, 3, ...)</span></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>d3[<span class="st">&#39;bin&#39;</span>] <span class="op">=</span> d3[<span class="st">&#39;label&#39;</span>].cat.codes <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a><span class="co"># Lower and Upper bounds with width of 5</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>d3[<span class="st">&#39;lower&#39;</span>] <span class="op">=</span> (d3[<span class="st">&#39;bin&#39;</span>] <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> <span class="dv">5</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>d3[<span class="st">&#39;upper&#39;</span>] <span class="op">=</span> d3[<span class="st">&#39;bin&#39;</span>] <span class="op">*</span> <span class="dv">5</span></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a><span class="co"># Computes the mid point for each bin</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a>d3[<span class="st">&#39;midpoint&#39;</span>] <span class="op">=</span> (d3[<span class="st">&#39;lower&#39;</span>] <span class="op">+</span> d3[<span class="st">&#39;upper&#39;</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a><span class="co"># Check it!</span></span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a>d3</span></code></pre></div>
<pre><code>##        label  r_obs  bin  lower  upper  midpoint
## 0     (0, 5]     17    1      0      5       2.5
## 1    (5, 10]     13    2      5     10       7.5
## 2   (10, 15]      3    3     10     15      12.5
## 3   (15, 20]      7    4     15     20      17.5
## 4   (20, 25]      2    5     20     25      22.5
## 5   (25, 30]      2    6     25     30      27.5
## 6   (30, 35]      3    7     30     35      32.5
## 7   (35, 40]      0    8     35     40      37.5
## 8   (40, 45]      0    9     40     45      42.5
## 9   (45, 50]      1   10     45     50      47.5
## 10  (50, 55]      2   11     50     55      52.5</code></pre>
<hr />
<p><br>
<br></p>
</div>
<div id="learning-check-1" class="section level2 unnumbered LC hasAnchor">
<h2>Learning Check 1<a href="#learning-check-1" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p><strong>Question</strong></p>
<p>A small start-up is product testing a new super-effective mask. They product tested 25 masks over 60 days. They contract you to analyze the masks’ lifespan data, recorded below as the number of days to failure.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="co"># Lifespan in days</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>supermasks <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">9</span>, <span class="dv">13</span>, <span class="dv">15</span>, <span class="dv">17</span>, <span class="dv">19</span>, </span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>            <span class="dv">20</span>, <span class="dv">21</span>, <span class="dv">23</span>, <span class="dv">24</span>, <span class="dv">24</span>, <span class="dv">24</span>, <span class="dv">32</span>, <span class="dv">33</span>, <span class="dv">33</span>, <span class="dv">34</span>, <span class="dv">54</span>]</span></code></pre></div>
<ol style="list-style-type: decimal">
<li><p>Cross-tabulate the lifespan distribution in intervals of <code>7 days</code>.</p></li>
<li><p>What’s the last 7-day interval?</p></li>
<li><p>How many masks are expected to fail within that interval?</p></li>
<li><p>What percentage of masks are expected to fail <em>within 28 days</em>?</p></li>
</ol>
<details>
<summary>
<strong>[View Answer!]</strong>
</summary>
<ol style="list-style-type: decimal">
<li>Cross-tabulate the lifespan distribution in intervals of 7 days.</li>
</ol>
<pre><code>##       label  r_obs  bin  lower  upper  midpoint
## 0    (0, 7]      9    1      0      7       3.5
## 1   (7, 14]      2    2      7     14      10.5
## 2  (14, 21]      5    3     14     21      17.5
## 3  (21, 28]      4    4     21     28      24.5
## 4  (28, 35]      4    5     28     35      31.5
## 5  (35, 42]      0    6     35     42      38.5
## 6  (42, 49]      0    7     42     49      45.5
## 7  (49, 56]      1    8     49     56      52.5</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>What’s the last 7-day interval?</li>
</ol>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="co"># Find the bin with the highest bin id</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>d[d[<span class="st">&quot;bin&quot;</span>] <span class="op">==</span> d[<span class="st">&quot;bin&quot;</span>].<span class="bu">max</span>()]</span></code></pre></div>
<pre><code>##       label  r_obs  bin  lower  upper  midpoint
## 7  (49, 56]      1    8     49     56      52.5</code></pre>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="co"># or</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>d.tail(<span class="dv">1</span>)</span></code></pre></div>
<pre><code>##       label  r_obs  bin  lower  upper  midpoint
## 7  (49, 56]      1    8     49     56      52.5</code></pre>
<div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="co"># or find the bin with the highest midpoint</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>d[d[<span class="st">&quot;midpoint&quot;</span>] <span class="op">==</span> d[<span class="st">&quot;midpoint&quot;</span>].<span class="bu">max</span>()]</span></code></pre></div>
<pre><code>##       label  r_obs  bin  lower  upper  midpoint
## 7  (49, 56]      1    8     49     56      52.5</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>How many masks are expected to fail within that interval?</li>
</ol>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="co"># Find the count of masks to fail `r_obs` within that interval</span></span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>d.loc[d[<span class="st">&quot;bin&quot;</span>] <span class="op">==</span> d[<span class="st">&quot;bin&quot;</span>].<span class="bu">max</span>(), [<span class="st">&quot;label&quot;</span>, <span class="st">&quot;r_obs&quot;</span>]]</span></code></pre></div>
<pre><code>##       label  r_obs
## 7  (49, 56]      1</code></pre>
<ol start="4" style="list-style-type: decimal">
<li>What percentage of masks are expected to fail <em>within 28 days</em>?</li>
</ol>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>result <span class="op">=</span> (</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>  d.assign(</span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a>    <span class="co"># Calculate cumulative failures</span></span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a>    r_cumulative <span class="op">=</span> d[<span class="st">&quot;r_obs&quot;</span>].cumsum(),</span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a>    <span class="co"># Calculate cumulative percentage</span></span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a>    percent <span class="op">=</span> d[<span class="st">&quot;r_obs&quot;</span>].cumsum() <span class="op">/</span> d[<span class="st">&quot;r_obs&quot;</span>].<span class="bu">sum</span>()</span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a>)</span>
<span id="cb25-8"><a href="#cb25-8" tabindex="-1"></a><span class="co"># Filter to adjust our failures within 28 days</span></span>
<span id="cb25-9"><a href="#cb25-9" tabindex="-1"></a>.loc[d[<span class="st">&quot;midpoint&quot;</span>] <span class="op">&lt;=</span> <span class="dv">28</span>]</span>
<span id="cb25-10"><a href="#cb25-10" tabindex="-1"></a>)</span>
<span id="cb25-11"><a href="#cb25-11" tabindex="-1"></a></span>
<span id="cb25-12"><a href="#cb25-12" tabindex="-1"></a>result</span></code></pre></div>
<pre><code>##       label  r_obs  bin  lower  upper  midpoint  r_cumulative  percent
## 0    (0, 7]      9    1      0      7       3.5             9     0.36
## 1   (7, 14]      2    2      7     14      10.5            11     0.44
## 2  (14, 21]      5    3     14     21      17.5            16     0.64
## 3  (21, 28]      4    4     21     28      24.5            20     0.80</code></pre>
</details>
<p><br>
<br>
<br></p>
</div>
<div id="estimating-lambda" class="section level2 hasAnchor" number="1.4">
<h2><span class="header-section-number">1.4</span> Estimating Lambda<a href="#estimating-lambda" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Sometimes, we don’t have access to the full raw data of times to failure for a product. Often, we only have access to cross-tabulated data released by companies. How then are we supposed to analyze product failure and reliability, if we cannot compute it directly? Even if we do not have <em>raw</em> data, we can still estimate the <strong>failure rate</strong> <span class="math inline">\(\lambda\)</span> for a component. Here’s a few ways!</p>
<div id="lambda-from-complete-sample" class="section level3 hasAnchor" number="1.4.1">
<h3><span class="header-section-number">1.4.1</span> Lambda from Complete Sample<a href="#lambda-from-complete-sample" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>If we have a complete sample of data (eg. not censored), then we can just calculate: $ = $.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="co"># Eg.</span></span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a><span class="dv">1</span> <span class="op">/</span> masks[<span class="st">&#39;left_earloop&#39;</span>].mean()</span></code></pre></div>
<pre><code>## 0.07485029940119761</code></pre>
</div>
<div id="hatlambda-from-cross-tabulation" class="section level3 hasAnchor" number="1.4.2">
<h3><span class="header-section-number">1.4.2</span> <span class="math inline">\(\hat{\lambda}\)</span> from Cross-Tabulation<a href="#hatlambda-from-cross-tabulation" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Alternatively, if our data is censored or pre-tabulated into groups, we may need to use the <code>midpoint</code> and <code>count</code> of failures in each <code>bin</code> to calculate the failure rate <span class="math inline">\(\lambda\)</span>. But, because this is an <em>estimate</em>, subject to error, we call it <span class="math inline">\(\hat{\lambda}\)</span> (said “lambda-hat”). Here are the 3 kinds of cross-tabulated samples you might encounter.</p>
<ol style="list-style-type: decimal">
<li><p><strong>Tabulated, No Censoring</strong>: tallied up in equally sized bins. All products eventually fail, yielding complete sample of times to failure.</p></li>
<li><p><strong>Tabulated, Type I Censoring</strong>: experiment stops when time <span class="math inline">\(t\)</span> reaches <span class="math inline">\(limit\)</span>.</p></li>
<li><p><strong>Tabulated, Type II Censoring</strong>: experiment stops when number of units failed <span class="math inline">\(n_{failed}\)</span> reaches <span class="math inline">\(limit\)</span>.</p></li>
</ol>
<p>For example, if we receive just the <code>d3</code> DataFrame we made above, how do we estimate <span class="math inline">\(\lambda\)</span> from it?</p>
<p>We will need:</p>
<ul>
<li><p><span class="math inline">\(r\)</span>: total failures (<code>sum(r_obs)</code>)</p></li>
<li><p><span class="math inline">\(n\)</span>: total observations (failed or not) (provided; otherwise, <span class="math inline">\(n = r\)</span>)</p></li>
<li><p><span class="math inline">\(\sum_{i=1}^{r}{t_i}\)</span>: total unit-hours (<code>sum(midpoint*r_obs)</code>)</p></li>
<li><p><span class="math inline">\(T\)</span>: timestep of (1) last failure observed (sometimes written <span class="math inline">\(t_r\)</span>) or (2) last timestep recorded; usually obtained by <code>max(midpoint)</code>.</p></li>
<li><p>Unless some cases do not fail, <span class="math inline">\((n - r)t_z\)</span> will cancel out as <code>0</code>.</p></li>
</ul>
<p><span class="math display">\[ \hat{\lambda} = \frac{ r  }{ \sum_{i=1}^{r}{t_i}  +  (n - r)t_z} \]</span></p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="co"># Let&#39;s calculate it!</span></span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" tabindex="-1"></a><span class="co"># d4 = pd.DataFrame({</span></span>
<span id="cb29-4"><a href="#cb29-4" tabindex="-1"></a><span class="co">#     &#39;r&#39;: [d3[&#39;r_obs&#39;].sum()],  # total failures</span></span>
<span id="cb29-5"><a href="#cb29-5" tabindex="-1"></a><span class="co">#     &#39;hours&#39;: [(d3[&#39;midpoint&#39;] * d3[&#39;r_obs&#39;]).sum()],  # total failure-hours</span></span>
<span id="cb29-6"><a href="#cb29-6" tabindex="-1"></a><span class="co">#     &#39;n&#39;: [d3[&#39;r_obs&#39;].sum()],  # in this case, total failures = total obs</span></span>
<span id="cb29-7"><a href="#cb29-7" tabindex="-1"></a><span class="co">#     &#39;tz&#39;: [d3[&#39;midpoint&#39;].max()],  # end of study period</span></span>
<span id="cb29-8"><a href="#cb29-8" tabindex="-1"></a><span class="co"># })</span></span>
<span id="cb29-9"><a href="#cb29-9" tabindex="-1"></a><span class="co"># # Calculate lambda hat!</span></span>
<span id="cb29-10"><a href="#cb29-10" tabindex="-1"></a><span class="co"># d4[&#39;lambda_hat&#39;] = d4[&#39;r&#39;] / (d4[&#39;hours&#39;] + (d4[&#39;n&#39;] - d4[&#39;r&#39;]) * d4[&#39;tz&#39;])</span></span>
<span id="cb29-11"><a href="#cb29-11" tabindex="-1"></a><span class="co"># d4</span></span>
<span id="cb29-12"><a href="#cb29-12" tabindex="-1"></a></span>
<span id="cb29-13"><a href="#cb29-13" tabindex="-1"></a>r <span class="op">=</span> d3[<span class="st">&quot;r_obs&quot;</span>].<span class="bu">sum</span>() <span class="co"># total failures</span></span>
<span id="cb29-14"><a href="#cb29-14" tabindex="-1"></a>hours <span class="op">=</span> (d3[<span class="st">&quot;midpoint&quot;</span>] <span class="op">*</span> d3[<span class="st">&quot;r_obs&quot;</span>]).<span class="bu">sum</span>()  <span class="co"># total failure-hours</span></span>
<span id="cb29-15"><a href="#cb29-15" tabindex="-1"></a>n <span class="op">=</span> r  <span class="co"># in this case, total failures = total obs</span></span>
<span id="cb29-16"><a href="#cb29-16" tabindex="-1"></a>tz <span class="op">=</span> d3[<span class="st">&quot;midpoint&quot;</span>].<span class="bu">max</span>() <span class="co"># end of study period</span></span>
<span id="cb29-17"><a href="#cb29-17" tabindex="-1"></a></span>
<span id="cb29-18"><a href="#cb29-18" tabindex="-1"></a><span class="co"># Calculate lambda hat!</span></span>
<span id="cb29-19"><a href="#cb29-19" tabindex="-1"></a>lambda_hat <span class="op">=</span> r <span class="op">/</span> (hours <span class="op">+</span> (n <span class="op">-</span> r) <span class="op">*</span> tz)</span>
<span id="cb29-20"><a href="#cb29-20" tabindex="-1"></a></span>
<span id="cb29-21"><a href="#cb29-21" tabindex="-1"></a><span class="co"># Combine the results!</span></span>
<span id="cb29-22"><a href="#cb29-22" tabindex="-1"></a>d4 <span class="op">=</span> pd.DataFrame({</span>
<span id="cb29-23"><a href="#cb29-23" tabindex="-1"></a>  <span class="st">&quot;r&quot;</span>: [r],</span>
<span id="cb29-24"><a href="#cb29-24" tabindex="-1"></a>  <span class="st">&quot;hours&quot;</span>: [hours],</span>
<span id="cb29-25"><a href="#cb29-25" tabindex="-1"></a>  <span class="st">&quot;tz&quot;</span>: [tz],</span>
<span id="cb29-26"><a href="#cb29-26" tabindex="-1"></a>  <span class="st">&quot;lambda_hat&quot;</span>: [lambda_hat]</span>
<span id="cb29-27"><a href="#cb29-27" tabindex="-1"></a>})</span>
<span id="cb29-28"><a href="#cb29-28" tabindex="-1"></a>d4</span></code></pre></div>
<pre><code>##     r  hours    tz  lambda_hat
## 0  50  650.0  52.5    0.076923</code></pre>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="co"># Let&#39;s compare</span></span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a><span class="dv">1</span> <span class="op">/</span> (masks[<span class="st">&quot;left_earloop&quot;</span>]).mean()</span></code></pre></div>
<pre><code>## 0.07485029940119761</code></pre>
<hr />
<p><br>
<br></p>
</div>
</div>
<div id="learning-check-2" class="section level2 unnumbered LC hasAnchor">
<h2>Learning Check 2<a href="#learning-check-2" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p><strong>Question</strong></p>
<p>The same startup testing that super-effective mask needs to estimate their failure rate, but they only have crosstabulated data. They’ve provided it to you below, using a dictionary (similar to R’s <code>tribble()</code>).</p>
<p>Estimate <span class="math inline">\(\hat{\lambda}\)</span> from the cross-tabulated data, knowing that they tested 25 masks over 60 days.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a><span class="co"># Days to failure - note: corrected the data (bin 4 should have lower=21)</span></span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a>a <span class="op">=</span> pd.DataFrame({</span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a>    <span class="st">&#39;bin&#39;</span>: [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>],</span>
<span id="cb33-4"><a href="#cb33-4" tabindex="-1"></a>    <span class="st">&#39;label&#39;</span>: [<span class="st">&#39;[0,7]&#39;</span>, <span class="st">&#39;(7,14]&#39;</span>, <span class="st">&#39;(14,21]&#39;</span>, <span class="st">&#39;(21,28]&#39;</span>, <span class="st">&#39;(28,35]&#39;</span>, <span class="st">&#39;(35,42]&#39;</span>, <span class="st">&#39;(42,49]&#39;</span>, <span class="st">&#39;(49,56]&#39;</span>],</span>
<span id="cb33-5"><a href="#cb33-5" tabindex="-1"></a>    <span class="st">&#39;r_obs&#39;</span>: [<span class="dv">9</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>],</span>
<span id="cb33-6"><a href="#cb33-6" tabindex="-1"></a>    <span class="st">&#39;lower&#39;</span>: [<span class="dv">0</span>, <span class="dv">7</span>, <span class="dv">14</span>, <span class="dv">21</span>, <span class="dv">28</span>, <span class="dv">35</span>, <span class="dv">42</span>, <span class="dv">49</span>],</span>
<span id="cb33-7"><a href="#cb33-7" tabindex="-1"></a>    <span class="st">&#39;upper&#39;</span>: [<span class="dv">7</span>, <span class="dv">14</span>, <span class="dv">21</span>, <span class="dv">28</span>, <span class="dv">35</span>, <span class="dv">42</span>, <span class="dv">49</span>, <span class="dv">56</span>]</span>
<span id="cb33-8"><a href="#cb33-8" tabindex="-1"></a>})</span>
<span id="cb33-9"><a href="#cb33-9" tabindex="-1"></a></span>
<span id="cb33-10"><a href="#cb33-10" tabindex="-1"></a>a</span></code></pre></div>
<pre><code>##    bin    label  r_obs  lower  upper
## 0    1    [0,7]      9      0      7
## 1    2   (7,14]      2      7     14
## 2    3  (14,21]      5     14     21
## 3    4  (21,28]      4     21     28
## 4    5  (28,35]      4     28     35
## 5    6  (35,42]      0     35     42
## 6    7  (42,49]      0     42     49
## 7    8  (49,56]      1     49     56</code></pre>
<details>
<summary>
<strong>[View Answer!]</strong>
</summary>
<p>Estimate <span class="math inline">\(\hat{\lambda}\)</span> from the cross-tabulated data, knowing that they tested 25 masks over 60 days.</p>
<pre><code>##     r   days   n    tz  lambda_hat
## 0  25  416.5  25  52.5    0.060024</code></pre>
</details>
<p><br>
<br></p>
<div id="confidence-intervals-for-hatlambda" class="section level3 hasAnchor" number="1.4.3">
<h3><span class="header-section-number">1.4.3</span> Confidence Intervals for <span class="math inline">\(\hat{\lambda}\)</span><a href="#confidence-intervals-for-hatlambda" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Also, our estimate of lambda might be slightly off due to random sampling error. (Every time you take a random sample, there’s a little change, right?) That’s why we call it <span class="math inline">\(\hat{\lambda}\)</span>. So, let’s build a <strong>confidence interval</strong> around our estimate.</p>
<div id="k-factor" class="section level4 hasAnchor" number="1.4.3.1">
<h4><span class="header-section-number">1.4.3.1</span> <span class="math inline">\(k\)</span> factor<a href="#k-factor" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>We can build confidence intervals around our point estimate <span class="math inline">\(\hat{\lambda}\)</span> using something called a <strong><span class="math inline">\(k\)</span> factor.</strong> We will <strong>weight</strong> <span class="math inline">\(\hat{\lambda}\)</span> by a factor <span class="math inline">\(k\)</span>, to get a slightly higher/slightly lower estimated failure rate that shows our confidence interval.</p>
<ul>
<li><p>This factor <span class="math inline">\(k\)</span> may be greater depending on (1) the total number of failures <span class="math inline">\(r\)</span> and (2) our level of acceptable error (<span class="math inline">\(alpha\)</span>).</p></li>
<li><p>Like any statistic, our estimate <span class="math inline">\(\hat{\lambda}\)</span> has a full <em>sampling distribution</em> of <span class="math inline">\(\hat{\lambda}\)</span> values we could get due to random sampling error, with some of them occurring more frequently than others.</p></li>
<li><p>We want to find the upper and lower bounds around the 90%, 95%, or perhaps 99% <em>most common</em> (middle-most) values in that sampling distribution. So, if <span class="math inline">\(alpha = 0.10\)</span>, we’re going to get a 90% confidence interval (dubbed <span class="math inline">\(interval\)</span>) spanning from the 5%~95% of that sampling distribution.</p></li>
</ul>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a><span class="co"># To calculate a &#39;one-tailed&#39; 90% CI (eg. we only care if above 90%)</span></span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a>alpha <span class="op">=</span> <span class="fl">0.10</span></span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a>ci <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> alpha</span>
<span id="cb36-4"><a href="#cb36-4" tabindex="-1"></a>ci</span></code></pre></div>
<pre><code>## 0.9</code></pre>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a><span class="co"># To adjust this to be &#39;two-tailed&#39; 90% CI (eg. we care if below 5% or above 95%)...</span></span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a><span class="fl">0.5</span> <span class="op">+</span> (ci <span class="op">/</span> <span class="dv">2</span>)</span></code></pre></div>
<pre><code>## 0.95</code></pre>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a><span class="fl">0.5</span> <span class="op">-</span> ci <span class="op">/</span> <span class="dv">2</span></span></code></pre></div>
<pre><code>## 0.04999999999999999</code></pre>
</div>
<div id="k-factor-by-type-of-data" class="section level4 hasAnchor" number="1.4.3.2">
<h4><span class="header-section-number">1.4.3.2</span> <span class="math inline">\(k\)</span> factor by Type of Data<a href="#k-factor-by-type-of-data" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<ul>
<li><strong>No Censoring</strong>: If we have complete data (all observations failed!), using this formula to calculate factor <span class="math inline">\(k\)</span>:</li>
</ul>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" tabindex="-1"></a><span class="co"># For example, let&#39;s say r = 50</span></span>
<span id="cb42-2"><a href="#cb42-2" tabindex="-1"></a>r <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb42-3"><a href="#cb42-3" tabindex="-1"></a>k <span class="op">=</span> chi2.ppf(ci, df<span class="op">=</span><span class="dv">2</span><span class="op">*</span>r) <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>r)</span></code></pre></div>
<ul>
<li><strong>Time-Censoring</strong>: If we only record up to a specific time (eg. planning an experiment), use <strong>this</strong> formula to calculate factor <span class="math inline">\(k\)</span>, setting as the degrees of freedom <span class="math inline">\(df = 2(r+1)\)</span>.</li>
</ul>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" tabindex="-1"></a><span class="co"># For example, let&#39;s say r = 50</span></span>
<span id="cb43-2"><a href="#cb43-2" tabindex="-1"></a>r <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb43-3"><a href="#cb43-3" tabindex="-1"></a>k <span class="op">=</span> chi2.ppf(ci, df<span class="op">=</span><span class="dv">2</span><span class="op">*</span>(r<span class="op">+</span><span class="dv">1</span>)) <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>r)</span></code></pre></div>
<p>So, since we do not have time censoring in our <code>d4</code> dataset, we can go ahead an calculate the <code>df = 2*r</code> and compute the 90% <code>lower</code> and <code>upper</code> confidence intervals.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a>result <span class="op">=</span> pd.DataFrame({</span>
<span id="cb44-2"><a href="#cb44-2" tabindex="-1"></a>    <span class="st">&#39;lambda_hat&#39;</span>: [d4[<span class="st">&#39;lambda_hat&#39;</span>].iloc[<span class="dv">0</span>]],</span>
<span id="cb44-3"><a href="#cb44-3" tabindex="-1"></a>    <span class="st">&#39;r&#39;</span>: [d4[<span class="st">&#39;r&#39;</span>].iloc[<span class="dv">0</span>]],</span>
<span id="cb44-4"><a href="#cb44-4" tabindex="-1"></a>    <span class="st">&#39;k_upper&#39;</span>: [chi2.ppf(<span class="fl">0.95</span>, df<span class="op">=</span><span class="dv">2</span><span class="op">*</span>d4[<span class="st">&#39;r&#39;</span>].iloc[<span class="dv">0</span>]) <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>d4[<span class="st">&#39;r&#39;</span>].iloc[<span class="dv">0</span>])],</span>
<span id="cb44-5"><a href="#cb44-5" tabindex="-1"></a>    <span class="st">&#39;k_lower&#39;</span>: [chi2.ppf(<span class="fl">0.05</span>, df<span class="op">=</span><span class="dv">2</span><span class="op">*</span>d4[<span class="st">&#39;r&#39;</span>].iloc[<span class="dv">0</span>]) <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>d4[<span class="st">&#39;r&#39;</span>].iloc[<span class="dv">0</span>])],</span>
<span id="cb44-6"><a href="#cb44-6" tabindex="-1"></a>})</span>
<span id="cb44-7"><a href="#cb44-7" tabindex="-1"></a>result[<span class="st">&#39;lower&#39;</span>] <span class="op">=</span> result[<span class="st">&#39;lambda_hat&#39;</span>] <span class="op">*</span> result[<span class="st">&#39;k_lower&#39;</span>]</span>
<span id="cb44-8"><a href="#cb44-8" tabindex="-1"></a>result[<span class="st">&#39;upper&#39;</span>] <span class="op">=</span> result[<span class="st">&#39;lambda_hat&#39;</span>] <span class="op">*</span> result[<span class="st">&#39;k_upper&#39;</span>]</span>
<span id="cb44-9"><a href="#cb44-9" tabindex="-1"></a>result</span></code></pre></div>
<pre><code>##    lambda_hat   r   k_upper   k_lower     lower     upper
## 0    0.076923  50  1.243421  0.779295  0.059946  0.095648</code></pre>
</div>
<div id="k-factor-functions" class="section level4 hasAnchor" number="1.4.3.3">
<h4><span class="header-section-number">1.4.3.3</span> <span class="math inline">\(k\)</span> factor functions<a href="#k-factor-functions" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>🧮 Here are some helper functions from <code>functions.functions_kfactors</code> that make it easy to calculate and visualize k-factors used in confidence intervals for failure rates!</p>
<p>This <code>qk</code> function is useful when you need the upper and lower k-factor for a given probability <em>p</em> and number of failures <em>r</em>.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a><span class="im">from</span> functions.functions_kfactors <span class="im">import</span> qk</span>
<span id="cb46-2"><a href="#cb46-2" tabindex="-1"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb46-3"><a href="#cb46-3" tabindex="-1"></a><span class="co">k-factor Quantiles</span></span>
<span id="cb46-4"><a href="#cb46-4" tabindex="-1"></a></span>
<span id="cb46-5"><a href="#cb46-5" tabindex="-1"></a><span class="co">Function to return quantiles for k-factors.</span></span>
<span id="cb46-6"><a href="#cb46-6" tabindex="-1"></a><span class="co">Intended for estimating confidence intervals for failure rates.</span></span>
<span id="cb46-7"><a href="#cb46-7" tabindex="-1"></a></span>
<span id="cb46-8"><a href="#cb46-8" tabindex="-1"></a><span class="co">Parameters:</span></span>
<span id="cb46-9"><a href="#cb46-9" tabindex="-1"></a><span class="co">p: float or array of probabilities / percentile(s)</span></span>
<span id="cb46-10"><a href="#cb46-10" tabindex="-1"></a><span class="co">r: int number of failures (non-negative integers; can include zero)</span></span>
<span id="cb46-11"><a href="#cb46-11" tabindex="-1"></a><span class="co">time: bool logical; is case time-censored data?</span></span>
<span id="cb46-12"><a href="#cb46-12" tabindex="-1"></a><span class="co">failure: bool logical; is case failure-censored data?</span></span>
<span id="cb46-13"><a href="#cb46-13" tabindex="-1"></a><span class="co">&quot;&quot;&quot;</span></span></code></pre></div>
<pre><code>## &#39;\nk-factor Quantiles\n\nFunction to return quantiles for k-factors.\nIntended for estimating confidence intervals for failure rates.\n\nParameters:\np: float or array of probabilities / percentile(s)\nr: int number of failures (non-negative integers; can include zero)\ntime: bool logical; is case time-censored data?\nfailure: bool logical; is case failure-censored data?\n&#39;</code></pre>
<div class="sourceCode" id="cb48"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a><span class="co"># Let&#39;s try an example of 95th percentile k-factor for a sample with 20 failures</span></span>
<span id="cb48-2"><a href="#cb48-2" tabindex="-1"></a>qk(p<span class="op">=</span><span class="fl">0.95</span>, r<span class="op">=</span><span class="dv">20</span>)</span></code></pre></div>
<pre><code>## 1.3939619819721756</code></pre>
<p>This <code>rk</code> function generates random samples of k-factor values. It’s useful when you want to run simulations and make plots to visualize the spread.</p>
<p><img src="matplotlib_figures/k_samples.png" width="100%" /></p>
<p>If you already have the k-factor value and want to know what percentile it is, use this <code>pk</code> function to find out!</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a><span class="kw">def</span> pk(q, r, time<span class="op">=</span><span class="va">False</span>, failure<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb50-2"><a href="#cb50-2" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb50-3"><a href="#cb50-3" tabindex="-1"></a><span class="co">    k-factor Cumulative Distribution Function</span></span>
<span id="cb50-4"><a href="#cb50-4" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb50-5"><a href="#cb50-5" tabindex="-1"></a><span class="co">    Function to return cumulative probabilities / percentiles given a supplied k-factor quantile `q`.</span></span>
<span id="cb50-6"><a href="#cb50-6" tabindex="-1"></a><span class="co">    Intended for confidence intervals for failure rates.</span></span>
<span id="cb50-7"><a href="#cb50-7" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb50-8"><a href="#cb50-8" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb50-9"><a href="#cb50-9" tabindex="-1"></a><span class="co">    q: float or array of quantiles (k-factors)</span></span>
<span id="cb50-10"><a href="#cb50-10" tabindex="-1"></a><span class="co">    r: int number of failures (non-negative integers; can include zero)</span></span>
<span id="cb50-11"><a href="#cb50-11" tabindex="-1"></a><span class="co">    time: bool logical; is case time-censored data?</span></span>
<span id="cb50-12"><a href="#cb50-12" tabindex="-1"></a><span class="co">    failure: bool logical; is case failure-censored data?</span></span>
<span id="cb50-13"><a href="#cb50-13" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb50-14"><a href="#cb50-14" tabindex="-1"></a>    <span class="im">from</span> scipy.interpolate <span class="im">import</span> interp1d</span>
<span id="cb50-15"><a href="#cb50-15" tabindex="-1"></a>    </span>
<span id="cb50-16"><a href="#cb50-16" tabindex="-1"></a>    <span class="co"># Construct an approximation function f, which gives the inverse of the Quantile Function,</span></span>
<span id="cb50-17"><a href="#cb50-17" tabindex="-1"></a>    <span class="co"># such that you use linear interpolation to return a Probability for any Quantile supplied.</span></span>
<span id="cb50-18"><a href="#cb50-18" tabindex="-1"></a>    by <span class="op">=</span> <span class="fl">0.001</span></span>
<span id="cb50-19"><a href="#cb50-19" tabindex="-1"></a>    p_range <span class="op">=</span> np.concatenate([</span>
<span id="cb50-20"><a href="#cb50-20" tabindex="-1"></a>        [by<span class="op">/</span><span class="dv">10000</span>, by<span class="op">/</span><span class="dv">1000</span>, by<span class="op">/</span><span class="dv">100</span>, by<span class="op">/</span><span class="dv">10</span>],</span>
<span id="cb50-21"><a href="#cb50-21" tabindex="-1"></a>        np.arange(<span class="dv">0</span>, <span class="dv">1</span>, by),</span>
<span id="cb50-22"><a href="#cb50-22" tabindex="-1"></a>        [<span class="dv">1</span> <span class="op">-</span> by<span class="op">/</span><span class="dv">10</span>, <span class="dv">1</span> <span class="op">-</span> by<span class="op">/</span><span class="dv">100</span>, <span class="dv">1</span> <span class="op">-</span> by<span class="op">/</span><span class="dv">1000</span>, <span class="dv">1</span> <span class="op">-</span> by<span class="op">/</span><span class="dv">10000</span>]</span>
<span id="cb50-23"><a href="#cb50-23" tabindex="-1"></a>    ])</span>
<span id="cb50-24"><a href="#cb50-24" tabindex="-1"></a>    p_range <span class="op">=</span> np.sort(p_range)</span>
<span id="cb50-25"><a href="#cb50-25" tabindex="-1"></a>    <span class="co"># Get the quantiles for that range</span></span>
<span id="cb50-26"><a href="#cb50-26" tabindex="-1"></a>    q_range <span class="op">=</span> qk(p<span class="op">=</span>p_range, r<span class="op">=</span>r, time<span class="op">=</span>time, failure<span class="op">=</span>failure)</span>
<span id="cb50-27"><a href="#cb50-27" tabindex="-1"></a>    </span>
<span id="cb50-28"><a href="#cb50-28" tabindex="-1"></a>    <span class="co"># Filter out NaN and infinite values</span></span>
<span id="cb50-29"><a href="#cb50-29" tabindex="-1"></a>    valid <span class="op">=</span> np.isfinite(q_range)</span>
<span id="cb50-30"><a href="#cb50-30" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> np.<span class="bu">any</span>(valid):</span>
<span id="cb50-31"><a href="#cb50-31" tabindex="-1"></a>        <span class="cf">return</span> np.full_like(q, np.nan)</span>
<span id="cb50-32"><a href="#cb50-32" tabindex="-1"></a>    q_range <span class="op">=</span> q_range[valid]</span>
<span id="cb50-33"><a href="#cb50-33" tabindex="-1"></a>    p_range <span class="op">=</span> p_range[valid]</span>
<span id="cb50-34"><a href="#cb50-34" tabindex="-1"></a>    </span>
<span id="cb50-35"><a href="#cb50-35" tabindex="-1"></a>    <span class="co"># Get the inverse quantile function using interpolation</span></span>
<span id="cb50-36"><a href="#cb50-36" tabindex="-1"></a>    f <span class="op">=</span> interp1d(q_range, p_range, kind<span class="op">=</span><span class="st">&#39;linear&#39;</span>, bounds_error<span class="op">=</span><span class="va">False</span>, fill_value<span class="op">=</span>np.nan)</span>
<span id="cb50-37"><a href="#cb50-37" tabindex="-1"></a>    <span class="co"># Return the expected CDF for that quantile  </span></span>
<span id="cb50-38"><a href="#cb50-38" tabindex="-1"></a>    p <span class="op">=</span> f(q)</span>
<span id="cb50-39"><a href="#cb50-39" tabindex="-1"></a>    <span class="cf">return</span> p</span>
<span id="cb50-40"><a href="#cb50-40" tabindex="-1"></a></span>
<span id="cb50-41"><a href="#cb50-41" tabindex="-1"></a><span class="co"># Probability that k-factor value &lt;= 2 with 20 failures</span></span>
<span id="cb50-42"><a href="#cb50-42" tabindex="-1"></a>pk(q<span class="op">=</span><span class="dv">2</span>, r<span class="op">=</span><span class="dv">20</span>)</span></code></pre></div>
<pre><code>## array(0.99968568)</code></pre>
<p>This function below estimates the probability densities for a given set of k-factor values. It is useful to visualize and compare distributions under different conditions.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" tabindex="-1"></a><span class="kw">def</span> dk(x, r, time<span class="op">=</span><span class="va">False</span>, failure<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb52-2"><a href="#cb52-2" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb52-3"><a href="#cb52-3" tabindex="-1"></a><span class="co">    k-factor Probability Density Function</span></span>
<span id="cb52-4"><a href="#cb52-4" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb52-5"><a href="#cb52-5" tabindex="-1"></a><span class="co">    Function to return probability densities given a supplied k-factor quantile `x`.</span></span>
<span id="cb52-6"><a href="#cb52-6" tabindex="-1"></a><span class="co">    Intended for visualizing sampling distributions of failure rates.</span></span>
<span id="cb52-7"><a href="#cb52-7" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb52-8"><a href="#cb52-8" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb52-9"><a href="#cb52-9" tabindex="-1"></a><span class="co">    x: float or array of quantiles (k-factors)</span></span>
<span id="cb52-10"><a href="#cb52-10" tabindex="-1"></a><span class="co">    r: int number of failures (non-negative integers; can include zero)</span></span>
<span id="cb52-11"><a href="#cb52-11" tabindex="-1"></a><span class="co">    time: bool logical; is case time-censored data?</span></span>
<span id="cb52-12"><a href="#cb52-12" tabindex="-1"></a><span class="co">    failure: bool logical; is case failure-censored data?</span></span>
<span id="cb52-13"><a href="#cb52-13" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb52-14"><a href="#cb52-14" tabindex="-1"></a>    <span class="im">from</span> scipy.stats <span class="im">import</span> gaussian_kde</span>
<span id="cb52-15"><a href="#cb52-15" tabindex="-1"></a>    </span>
<span id="cb52-16"><a href="#cb52-16" tabindex="-1"></a>    <span class="co"># Construct a range of quantiles corresponding to a range of cumulative probabilities</span></span>
<span id="cb52-17"><a href="#cb52-17" tabindex="-1"></a>    by <span class="op">=</span> <span class="fl">0.001</span></span>
<span id="cb52-18"><a href="#cb52-18" tabindex="-1"></a>    p_range <span class="op">=</span> np.concatenate([</span>
<span id="cb52-19"><a href="#cb52-19" tabindex="-1"></a>        [by<span class="op">/</span><span class="dv">10000</span>, by<span class="op">/</span><span class="dv">1000</span>, by<span class="op">/</span><span class="dv">100</span>, by<span class="op">/</span><span class="dv">10</span>],</span>
<span id="cb52-20"><a href="#cb52-20" tabindex="-1"></a>        np.arange(<span class="dv">0</span>, <span class="dv">1</span>, by),</span>
<span id="cb52-21"><a href="#cb52-21" tabindex="-1"></a>        [<span class="dv">1</span> <span class="op">-</span> by<span class="op">/</span><span class="dv">10</span>, <span class="dv">1</span> <span class="op">-</span> by<span class="op">/</span><span class="dv">100</span>, <span class="dv">1</span> <span class="op">-</span> by<span class="op">/</span><span class="dv">1000</span>, <span class="dv">1</span> <span class="op">-</span> by<span class="op">/</span><span class="dv">10000</span>]</span>
<span id="cb52-22"><a href="#cb52-22" tabindex="-1"></a>    ])</span>
<span id="cb52-23"><a href="#cb52-23" tabindex="-1"></a>    p_range <span class="op">=</span> np.sort(p_range)</span>
<span id="cb52-24"><a href="#cb52-24" tabindex="-1"></a>    <span class="co"># Get the quantiles for that range</span></span>
<span id="cb52-25"><a href="#cb52-25" tabindex="-1"></a>    q_range <span class="op">=</span> qk(p<span class="op">=</span>p_range, r<span class="op">=</span>r, time<span class="op">=</span>time, failure<span class="op">=</span>failure)</span>
<span id="cb52-26"><a href="#cb52-26" tabindex="-1"></a>    <span class="co"># Filter out NaN and infinite values</span></span>
<span id="cb52-27"><a href="#cb52-27" tabindex="-1"></a>    valid <span class="op">=</span> np.isfinite(q_range) <span class="op">&amp;</span> (q_range <span class="op">&gt;</span> <span class="dv">0</span>)</span>
<span id="cb52-28"><a href="#cb52-28" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> np.<span class="bu">any</span>(valid):</span>
<span id="cb52-29"><a href="#cb52-29" tabindex="-1"></a>        <span class="cf">return</span> np.full_like(x, np.nan)</span>
<span id="cb52-30"><a href="#cb52-30" tabindex="-1"></a>    q_range <span class="op">=</span> q_range[valid]</span>
<span id="cb52-31"><a href="#cb52-31" tabindex="-1"></a>    </span>
<span id="cb52-32"><a href="#cb52-32" tabindex="-1"></a>    <span class="co"># Fit a density curve using KDE</span></span>
<span id="cb52-33"><a href="#cb52-33" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb52-34"><a href="#cb52-34" tabindex="-1"></a>        kde <span class="op">=</span> gaussian_kde(q_range)</span>
<span id="cb52-35"><a href="#cb52-35" tabindex="-1"></a>        <span class="co"># Estimate density</span></span>
<span id="cb52-36"><a href="#cb52-36" tabindex="-1"></a>        d <span class="op">=</span> kde(x)</span>
<span id="cb52-37"><a href="#cb52-37" tabindex="-1"></a>        <span class="cf">return</span> d</span>
<span id="cb52-38"><a href="#cb52-38" tabindex="-1"></a>    <span class="cf">except</span>:</span>
<span id="cb52-39"><a href="#cb52-39" tabindex="-1"></a>        <span class="cf">return</span> np.full_like(x, np.nan)</span>
<span id="cb52-40"><a href="#cb52-40" tabindex="-1"></a></span>
<span id="cb52-41"><a href="#cb52-41" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb52-42"><a href="#cb52-42" tabindex="-1"></a>dk(x<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], r<span class="op">=</span><span class="dv">21</span>, time<span class="op">=</span><span class="va">True</span>, failure<span class="op">=</span><span class="va">False</span>)</span></code></pre></div>
<pre><code>## array([6.18799555e-06, 1.26305487e+00, 3.46089759e-03, 1.75194683e-09])</code></pre>
<hr />
<p><br>
<br></p>
</div>
</div>
</div>
<div id="learning-check-3" class="section level2 unnumbered LC hasAnchor">
<h2>Learning Check 3<a href="#learning-check-3" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p><strong>Question</strong></p>
<p>A small start-up is product testing a new super-effective mask. They product tested 25 masks over 60 days. They contracted you to analyze the cross-tabulated data, tabulated in intervals of 7 days. You have an estimate for <span class="math inline">\(\hat{\lambda}\)</span>, provided below.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" tabindex="-1"></a><span class="co"># Your estimate</span></span>
<span id="cb54-2"><a href="#cb54-2" tabindex="-1"></a>b <span class="op">=</span> pd.DataFrame({</span>
<span id="cb54-3"><a href="#cb54-3" tabindex="-1"></a>    <span class="st">&#39;r&#39;</span>: [<span class="dv">25</span>],</span>
<span id="cb54-4"><a href="#cb54-4" tabindex="-1"></a>    <span class="st">&#39;days&#39;</span>: [<span class="fl">416.5</span>],</span>
<span id="cb54-5"><a href="#cb54-5" tabindex="-1"></a>    <span class="st">&#39;n&#39;</span>: [<span class="dv">25</span>],</span>
<span id="cb54-6"><a href="#cb54-6" tabindex="-1"></a>    <span class="st">&#39;tz&#39;</span>: [<span class="fl">52.5</span>],</span>
<span id="cb54-7"><a href="#cb54-7" tabindex="-1"></a>    <span class="st">&#39;lambda_hat&#39;</span>: [<span class="fl">0.06002401</span>]</span>
<span id="cb54-8"><a href="#cb54-8" tabindex="-1"></a>})</span></code></pre></div>
<p>Estimate a 95% confidence interval for <span class="math inline">\(\hat{\lambda}\)</span>.</p>
<details>
<summary>
<strong>[View Answer!]</strong>
</summary>
<p>Estimate a 95% confidence interval for <span class="math inline">\(\hat{\lambda}\)</span>.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" tabindex="-1"></a><span class="co"># Get data...</span></span>
<span id="cb55-2"><a href="#cb55-2" tabindex="-1"></a>b <span class="op">=</span> pd.DataFrame({</span>
<span id="cb55-3"><a href="#cb55-3" tabindex="-1"></a>    <span class="st">&#39;r&#39;</span>: [<span class="dv">25</span>],</span>
<span id="cb55-4"><a href="#cb55-4" tabindex="-1"></a>    <span class="st">&#39;days&#39;</span>: [<span class="fl">416.5</span>],</span>
<span id="cb55-5"><a href="#cb55-5" tabindex="-1"></a>    <span class="st">&#39;n&#39;</span>: [<span class="dv">25</span>],</span>
<span id="cb55-6"><a href="#cb55-6" tabindex="-1"></a>    <span class="st">&#39;tz&#39;</span>: [<span class="fl">52.5</span>],</span>
<span id="cb55-7"><a href="#cb55-7" tabindex="-1"></a>    <span class="st">&#39;lambda_hat&#39;</span>: [<span class="fl">0.06002401</span>]</span>
<span id="cb55-8"><a href="#cb55-8" tabindex="-1"></a>})</span>
<span id="cb55-9"><a href="#cb55-9" tabindex="-1"></a></span>
<span id="cb55-10"><a href="#cb55-10" tabindex="-1"></a><span class="co"># And estimate lambda hat!</span></span>
<span id="cb55-11"><a href="#cb55-11" tabindex="-1"></a>c <span class="op">=</span> pd.DataFrame({</span>
<span id="cb55-12"><a href="#cb55-12" tabindex="-1"></a>    <span class="st">&#39;lambda_hat&#39;</span>: [b[<span class="st">&#39;lambda_hat&#39;</span>].iloc[<span class="dv">0</span>]],</span>
<span id="cb55-13"><a href="#cb55-13" tabindex="-1"></a>    <span class="st">&#39;r&#39;</span>: [b[<span class="st">&#39;r&#39;</span>].iloc[<span class="dv">0</span>]],</span>
<span id="cb55-14"><a href="#cb55-14" tabindex="-1"></a>    <span class="st">&#39;k_upper&#39;</span>: [chi2.ppf(<span class="fl">0.975</span>, df<span class="op">=</span><span class="dv">2</span><span class="op">*</span>b[<span class="st">&#39;r&#39;</span>].iloc[<span class="dv">0</span>]) <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>b[<span class="st">&#39;r&#39;</span>].iloc[<span class="dv">0</span>])],</span>
<span id="cb55-15"><a href="#cb55-15" tabindex="-1"></a>    <span class="st">&#39;k_lower&#39;</span>: [chi2.ppf(<span class="fl">0.025</span>, df<span class="op">=</span><span class="dv">2</span><span class="op">*</span>b[<span class="st">&#39;r&#39;</span>].iloc[<span class="dv">0</span>]) <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>b[<span class="st">&#39;r&#39;</span>].iloc[<span class="dv">0</span>])],</span>
<span id="cb55-16"><a href="#cb55-16" tabindex="-1"></a>})</span>
<span id="cb55-17"><a href="#cb55-17" tabindex="-1"></a>c[<span class="st">&#39;lower&#39;</span>] <span class="op">=</span> c[<span class="st">&#39;lambda_hat&#39;</span>] <span class="op">*</span> c[<span class="st">&#39;k_lower&#39;</span>]</span>
<span id="cb55-18"><a href="#cb55-18" tabindex="-1"></a>c[<span class="st">&#39;upper&#39;</span>] <span class="op">=</span> c[<span class="st">&#39;lambda_hat&#39;</span>] <span class="op">*</span> c[<span class="st">&#39;k_upper&#39;</span>]</span>
<span id="cb55-19"><a href="#cb55-19" tabindex="-1"></a><span class="co"># Check it</span></span>
<span id="cb55-20"><a href="#cb55-20" tabindex="-1"></a>c</span></code></pre></div>
<pre><code>##    lambda_hat   r   k_upper   k_lower     lower     upper
## 0    0.060024  25  1.428404  0.647147  0.038844  0.085739</code></pre>
</div>
<div id="planning-experiments" class="section level2 hasAnchor" number="1.5">
<h2><span class="header-section-number">1.5</span> Planning Experiments<a href="#planning-experiments" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>When developing a new product, you often need to make that product meet regulatory standards, eg. meet a specific <span class="math inline">\(\lambda\)</span> failure rate requirement. But as we just learned, estimated failure rates are dependent on the sample size of products and time range evaluated, and are subject to error. Even if we have a product whose <em>true failure rate</em> should be within range, our experiment might yield a <span class="math inline">\(\hat{\lambda}\)</span> that varies from it by chance and exceeds regulatory requirements. Further, (most) all experiments cost time and money! So we probably want to keep our experiment <em>as short as possible</em> (timely results) and use <em>as few products as possible</em> (less expensive). We often need to answer the following questions:</p>
<ul>
<li><p><em>What’s the minimum time we should run our test</em> to produce a failure rate <span class="math inline">\(\hat{\lambda}\)</span> that we can say <em>with confidence</em> is within limits?</p></li>
<li><p><em>What’s the minimum sample size we can run our test on</em> to produce a failure rate <span class="math inline">\(\hat{\lambda}\)</span> that we can say <em>with confidence</em> is within limits?</p></li>
<li><p><em>How confident are we</em> that our product has a failure rate within a specific limit <span class="math inline">\(\hat{\lambda}\)</span>?</p></li>
</ul>
<p>When planning an experiment, we can use the following formula to determine the necessary values of <span class="math inline">\(r\)</span>, <span class="math inline">\(t\)</span>, <span class="math inline">\(lambda\)</span>, <span class="math inline">\(k\)</span>, or <span class="math inline">\(n\)</span> for our experiment to function:</p>
<p><span class="math display">\[ \frac{r}{n \ t} \times k_{r, 1 - \alpha} = \hat{\lambda} \]</span></p>
<p><em>Note</em>: Experiment planning by definition makes time-censored datasets, so you’ll need your adjusted <span class="math inline">\(k\)</span> formula so that <span class="math inline">\(df = 2(r+1)\)</span>.</p>
<div id="example-minimum-sample-size" class="section level3 hasAnchor" number="1.5.1">
<h3><span class="header-section-number">1.5.1</span> Example: Minimum Sample Size<a href="#example-minimum-sample-size" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Let’s try an example. Imagine a company wants to test a new line of masks. Your company can budget <code>500</code> hours to test these masks’ elastic bands, and they accept that up to <code>10</code> of these masks may break in the process. Company policy anticipates a failure rate of just <code>0.00002</code> masks per hour, and we want to be <code>90</code>% confidence that the failure rate will not <em>exceed</em> this level. (But it’s fine if it goes below that level.)</p>
<p>If we aim to fit within these constraints, how many masks need to be tested in this product trial?</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" tabindex="-1"></a><span class="co"># Max failures</span></span>
<span id="cb57-2"><a href="#cb57-2" tabindex="-1"></a>r <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb57-3"><a href="#cb57-3" tabindex="-1"></a><span class="co"># Number of hours</span></span>
<span id="cb57-4"><a href="#cb57-4" tabindex="-1"></a>t <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb57-5"><a href="#cb57-5" tabindex="-1"></a><span class="co"># Max acceptable failure rate</span></span>
<span id="cb57-6"><a href="#cb57-6" tabindex="-1"></a>lambda_val <span class="op">=</span> <span class="fl">0.00002</span></span>
<span id="cb57-7"><a href="#cb57-7" tabindex="-1"></a></span>
<span id="cb57-8"><a href="#cb57-8" tabindex="-1"></a><span class="co"># Calculate a one-tailed confidence interval</span></span>
<span id="cb57-9"><a href="#cb57-9" tabindex="-1"></a>alpha <span class="op">=</span> <span class="fl">0.10</span></span>
<span id="cb57-10"><a href="#cb57-10" tabindex="-1"></a>ci <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> alpha</span>
<span id="cb57-11"><a href="#cb57-11" tabindex="-1"></a></span>
<span id="cb57-12"><a href="#cb57-12" tabindex="-1"></a><span class="co"># Use these ingredients to calculate the factor k, using time-censored rule df = 2*(r+1)</span></span>
<span id="cb57-13"><a href="#cb57-13" tabindex="-1"></a>k <span class="op">=</span> chi2.ppf(ci, df<span class="op">=</span><span class="dv">2</span><span class="op">*</span>(r<span class="op">+</span><span class="dv">1</span>)) <span class="op">/</span> (<span class="dv">2</span><span class="op">*</span>r)</span>
<span id="cb57-14"><a href="#cb57-14" tabindex="-1"></a></span>
<span id="cb57-15"><a href="#cb57-15" tabindex="-1"></a><span class="co"># Reformat </span></span>
<span id="cb57-16"><a href="#cb57-16" tabindex="-1"></a><span class="co"># r / (t*n) * k = lambda</span></span>
<span id="cb57-17"><a href="#cb57-17" tabindex="-1"></a>n <span class="op">=</span> k <span class="op">*</span> r <span class="op">/</span> (lambda_val <span class="op">*</span> t)</span>
<span id="cb57-18"><a href="#cb57-18" tabindex="-1"></a></span>
<span id="cb57-19"><a href="#cb57-19" tabindex="-1"></a><span class="co"># Check it!</span></span>
<span id="cb57-20"><a href="#cb57-20" tabindex="-1"></a>n</span></code></pre></div>
<pre><code>## 1540.6641171976512</code></pre>
<p>Looks like you’ll need a sample of about <code>py round(n, 0)</code> masks to be able to fit those constraints.</p>
<p><br>
<br></p>
</div>
</div>
<div id="chi-squared" class="section level2 hasAnchor" number="1.6">
<h2><span class="header-section-number">1.6</span> Chi-squared<a href="#chi-squared" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p><strong>Chi-squared</strong> (<span class="math inline">\(\chi^{2}\)</span>) is a special statistic used frequently to evaluate the relationship between two categorical variables. In this case, the first variable is the <code>type</code> of data (<code>observed</code> vs. <code>model</code>), while the second variable is <code>bin</code>.</p>
<div id="compute-chi-squared-from-scratch" class="section level3 hasAnchor" number="1.6.1">
<h3><span class="header-section-number">1.6.1</span> Compute Chi-squared from scratch<a href="#compute-chi-squared-from-scratch" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Back in Workshop 2, we <em>visually</em> compared several distributions to an observed distribution, to determine which fits best. But can we do that statistically? One way to do this is to chop our observed data into bins of <code>length</code> equal width using <code>pd.cut()</code>. We must specify:</p>
<p><strong>Step 1</strong> Crosstabulate Observed Values into Bins.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" tabindex="-1"></a><span class="co"># Let&#39;s repeat our process from before!</span></span>
<span id="cb59-2"><a href="#cb59-2" tabindex="-1"></a>c1 <span class="op">=</span> pd.DataFrame({<span class="st">&#39;t&#39;</span>: masks[<span class="st">&#39;left_earloop&#39;</span>]})</span>
<span id="cb59-3"><a href="#cb59-3" tabindex="-1"></a><span class="co"># Part 1.1: Split into bins</span></span>
<span id="cb59-4"><a href="#cb59-4" tabindex="-1"></a>c1[<span class="st">&#39;interval&#39;</span>] <span class="op">=</span> pd.cut(c1[<span class="st">&#39;t&#39;</span>], bins<span class="op">=</span><span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">int</span>(c1[<span class="st">&#39;t&#39;</span>].<span class="bu">max</span>()) <span class="op">+</span> <span class="dv">6</span>, <span class="dv">5</span>))</span>
<span id="cb59-5"><a href="#cb59-5" tabindex="-1"></a><span class="co"># Part 1.2: Tally up observed failures &#39;r_obs&#39; by bin</span></span>
<span id="cb59-6"><a href="#cb59-6" tabindex="-1"></a>c1 <span class="op">=</span> c1.groupby(<span class="st">&#39;interval&#39;</span>, dropna<span class="op">=</span><span class="va">False</span>, observed<span class="op">=</span><span class="va">True</span>).size().reset_index(name<span class="op">=</span><span class="st">&#39;r_obs&#39;</span>)</span>
<span id="cb59-7"><a href="#cb59-7" tabindex="-1"></a>c1 <span class="op">=</span> c1.sort_values(<span class="st">&#39;interval&#39;</span>).reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb59-8"><a href="#cb59-8" tabindex="-1"></a>c1[<span class="st">&#39;bin&#39;</span>] <span class="op">=</span> c1[<span class="st">&#39;interval&#39;</span>].cat.codes <span class="op">+</span> <span class="dv">1</span>  <span class="co"># R uses 1-based indexing</span></span>
<span id="cb59-9"><a href="#cb59-9" tabindex="-1"></a>c1[<span class="st">&#39;lower&#39;</span>] <span class="op">=</span> (c1[<span class="st">&#39;bin&#39;</span>] <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> <span class="dv">5</span></span>
<span id="cb59-10"><a href="#cb59-10" tabindex="-1"></a>c1[<span class="st">&#39;upper&#39;</span>] <span class="op">=</span> c1[<span class="st">&#39;bin&#39;</span>] <span class="op">*</span> <span class="dv">5</span></span>
<span id="cb59-11"><a href="#cb59-11" tabindex="-1"></a>c1[<span class="st">&#39;midpoint&#39;</span>] <span class="op">=</span> (c1[<span class="st">&#39;lower&#39;</span>] <span class="op">+</span> c1[<span class="st">&#39;upper&#39;</span>]) <span class="op">/</span> <span class="dv">2</span></span></code></pre></div>
<p><strong>Step 2</strong>: Calculate Observed and Expected Values per Bin.</p>
<p>Sometimes you might only receive <strong>tabulated data</strong>, meaning a table of bins, not the original vector. In that case, start from <strong>Step 2</strong>!</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a><span class="co"># Get any parameters you need (might need to be provided if only tabulated data)</span></span>
<span id="cb60-2"><a href="#cb60-2" tabindex="-1"></a>mystat <span class="op">=</span> pd.DataFrame({</span>
<span id="cb60-3"><a href="#cb60-3" tabindex="-1"></a>    <span class="st">&#39;lambda&#39;</span>: [<span class="dv">1</span> <span class="op">/</span> masks[<span class="st">&#39;left_earloop&#39;</span>].mean()],</span>
<span id="cb60-4"><a href="#cb60-4" tabindex="-1"></a>    <span class="st">&#39;n&#39;</span>: [<span class="bu">len</span>(masks)]  <span class="co"># total number of units under test</span></span>
<span id="cb60-5"><a href="#cb60-5" tabindex="-1"></a>})</span>
<span id="cb60-6"><a href="#cb60-6" tabindex="-1"></a><span class="co"># Get your &#39;model&#39; function</span></span>
<span id="cb60-7"><a href="#cb60-7" tabindex="-1"></a><span class="kw">def</span> f(t, lambda_val):</span>
<span id="cb60-8"><a href="#cb60-8" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span><span class="dv">1</span> <span class="op">*</span> lambda_val <span class="op">*</span> t)</span>
<span id="cb60-9"><a href="#cb60-9" tabindex="-1"></a><span class="co"># Note: expon.cdf(t, scale=1/lambda) is equivalent to f(t, lambda) for exponential distribution</span></span>
<span id="cb60-10"><a href="#cb60-10" tabindex="-1"></a></span>
<span id="cb60-11"><a href="#cb60-11" tabindex="-1"></a><span class="co"># Now calculate expected units to fail per interval, r_exp</span></span>
<span id="cb60-12"><a href="#cb60-12" tabindex="-1"></a>c2 <span class="op">=</span> c1.copy()</span>
<span id="cb60-13"><a href="#cb60-13" tabindex="-1"></a>c2[<span class="st">&#39;p_upper&#39;</span>] <span class="op">=</span> f(t<span class="op">=</span>c2[<span class="st">&#39;upper&#39;</span>], lambda_val<span class="op">=</span>mystat[<span class="st">&#39;lambda&#39;</span>].iloc[<span class="dv">0</span>])</span>
<span id="cb60-14"><a href="#cb60-14" tabindex="-1"></a>c2[<span class="st">&#39;p_lower&#39;</span>] <span class="op">=</span> f(t<span class="op">=</span>c2[<span class="st">&#39;lower&#39;</span>], lambda_val<span class="op">=</span>mystat[<span class="st">&#39;lambda&#39;</span>].iloc[<span class="dv">0</span>])</span>
<span id="cb60-15"><a href="#cb60-15" tabindex="-1"></a>c2[<span class="st">&#39;p_fail&#39;</span>] <span class="op">=</span> c2[<span class="st">&#39;p_upper&#39;</span>] <span class="op">-</span> c2[<span class="st">&#39;p_lower&#39;</span>]</span>
<span id="cb60-16"><a href="#cb60-16" tabindex="-1"></a>c2[<span class="st">&#39;n_total&#39;</span>] <span class="op">=</span> mystat[<span class="st">&#39;n&#39;</span>].iloc[<span class="dv">0</span>]</span>
<span id="cb60-17"><a href="#cb60-17" tabindex="-1"></a>c2[<span class="st">&#39;r_exp&#39;</span>] <span class="op">=</span> c2[<span class="st">&#39;n_total&#39;</span>] <span class="op">*</span> c2[<span class="st">&#39;p_fail&#39;</span>]</span>
<span id="cb60-18"><a href="#cb60-18" tabindex="-1"></a><span class="co"># Check it!</span></span>
<span id="cb60-19"><a href="#cb60-19" tabindex="-1"></a>c2</span></code></pre></div>
<pre><code>##    interval  r_obs  bin  lower  ...   p_lower    p_fail  n_total      r_exp
## 0    (0, 5]     17    1      0  ...  0.000000  0.312196       50  15.609805
## 1   (5, 10]     13    2      5  ...  0.312196  0.214730       50  10.736485
## 2  (10, 15]      3    3     10  ...  0.526926  0.147692       50   7.384596
## 3  (15, 20]      7    4     15  ...  0.674618  0.101583       50   5.079154
## 4  (20, 25]      2    5     20  ...  0.776201  0.069869       50   3.493462
## 5  (25, 30]      2    6     25  ...  0.846070  0.048056       50   2.402817
## 6  (30, 35]      3    7     30  ...  0.894126  0.033053       50   1.652667
## 7  (45, 50]      1   10     45  ...  0.965551  0.010755       50   0.537749
## 8  (50, 55]      2   11     50  ...  0.976306  0.007397       50   0.369866
## 
## [9 rows x 11 columns]</code></pre>
<div class="sourceCode" id="cb62"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" tabindex="-1"></a><span class="co"># We only need a few of these columns; let&#39;s look at them:</span></span>
<span id="cb62-2"><a href="#cb62-2" tabindex="-1"></a>c2[[<span class="st">&#39;interval&#39;</span>, <span class="st">&#39;r_obs&#39;</span>, <span class="st">&#39;r_exp&#39;</span>, <span class="st">&#39;n_total&#39;</span>]]</span></code></pre></div>
<pre><code>##    interval  r_obs      r_exp  n_total
## 0    (0, 5]     17  15.609805       50
## 1   (5, 10]     13  10.736485       50
## 2  (10, 15]      3   7.384596       50
## 3  (15, 20]      7   5.079154       50
## 4  (20, 25]      2   3.493462       50
## 5  (25, 30]      2   2.402817       50
## 6  (30, 35]      3   1.652667       50
## 7  (45, 50]      1   0.537749       50
## 8  (50, 55]      2   0.369866       50</code></pre>
<p><strong>Step 3</strong>: Calculate Chi-squared Statistic</p>
<ul>
<li><p><strong>Chi-squared</strong> here represents the sum of ratios for each bin. Each ratio is the (1) squared difference between the observed and expected value over (2) the expected value. Ranges from 0 to infinity. The bigger (more positive) the statistic, the greater difference between the observed and expected data.</p></li>
<li><p><strong>Degrees of Freedom (df)</strong> is used as the standard deviation in the chi-squared distribution, to help evaluate <em>how extreme is our chi-squared statistic?</em></p></li>
<li><p><strong>Chi-squared Distribution</strong> is a distribution of squared deviations from a normal distribution centered at 0. This means it only has positive values.</p></li>
</ul>
<div class="sourceCode" id="cb64"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" tabindex="-1"></a>c3 <span class="op">=</span> pd.DataFrame({</span>
<span id="cb64-2"><a href="#cb64-2" tabindex="-1"></a>    <span class="st">&#39;chisq&#39;</span>: [((c2[<span class="st">&#39;r_obs&#39;</span>] <span class="op">-</span> c2[<span class="st">&#39;r_exp&#39;</span>])<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> c2[<span class="st">&#39;r_exp&#39;</span>]).<span class="bu">sum</span>()],</span>
<span id="cb64-3"><a href="#cb64-3" tabindex="-1"></a>    <span class="st">&#39;nbin&#39;</span>: [<span class="bu">len</span>(c2)],</span>
<span id="cb64-4"><a href="#cb64-4" tabindex="-1"></a>    <span class="st">&#39;np&#39;</span>: [<span class="dv">1</span>],  <span class="co"># Record number of parameters used (just lambda)</span></span>
<span id="cb64-5"><a href="#cb64-5" tabindex="-1"></a>    <span class="st">&#39;df&#39;</span>: [<span class="bu">len</span>(c2) <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> <span class="dv">1</span>]  <span class="co"># Calculate degree of freedom</span></span>
<span id="cb64-6"><a href="#cb64-6" tabindex="-1"></a>})</span>
<span id="cb64-7"><a href="#cb64-7" tabindex="-1"></a><span class="co"># Check it!</span></span>
<span id="cb64-8"><a href="#cb64-8" tabindex="-1"></a>c3</span></code></pre></div>
<pre><code>##        chisq  nbin  np  df
## 0  13.317152     9   1   7</code></pre>
<p><strong>Step 4</strong>: Calculate p-values and confidence intervals</p>
<p>Last, let’s use the <code>chi2.sf()</code> function (survival function, equivalent to 1 - CDF) to evaluate the Chi-squared distribution. We’ll find out:</p>
<ul>
<li><p><code>p_value</code>: what’s the probability of getting a value <strong>greater than or equal to</strong> (more extreme than) our observed chi-squared statistic?</p></li>
<li><p><strong>“statistically significant”</strong>: if our observed statistic is more extreme than most possible chi-squared statistics (eg. &gt;95% of the distribution), it’s probably not due to chance! We call it ‘statistically significant.’</p></li>
</ul>
<div class="sourceCode" id="cb66"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" tabindex="-1"></a><span class="co"># Calculate area remaining under the curve (survival function = 1 - CDF)</span></span>
<span id="cb66-2"><a href="#cb66-2" tabindex="-1"></a>c4 <span class="op">=</span> c3.copy()</span>
<span id="cb66-3"><a href="#cb66-3" tabindex="-1"></a>c4[<span class="st">&#39;p_value&#39;</span>] <span class="op">=</span> chi2.sf(x<span class="op">=</span>c3[<span class="st">&#39;chisq&#39;</span>].iloc[<span class="dv">0</span>], df<span class="op">=</span>c3[<span class="st">&#39;df&#39;</span>].iloc[<span class="dv">0</span>])</span>
<span id="cb66-4"><a href="#cb66-4" tabindex="-1"></a><span class="co"># Check</span></span>
<span id="cb66-5"><a href="#cb66-5" tabindex="-1"></a>c4</span></code></pre></div>
<pre><code>##        chisq  nbin  np  df   p_value
## 0  13.317152     9   1   7  0.064748</code></pre>
<p>For a visual representation:</p>
<pre><code>## &lt;ggplot: (640 x 480)&gt;</code></pre>
<p><br>
<br></p>
</div>
<div id="building-a-chi-squared-function" class="section level3 hasAnchor" number="1.6.2">
<h3><span class="header-section-number">1.6.2</span> Building a Chi-squared function<a href="#building-a-chi-squared-function" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>That was a lot of work! It might be more helpful for us to build our own <code>function</code> doing all those steps. Here’s a function I built, which should work pretty flexibly. You can improve it, tweak it, or use it for your own purposes. Our function <code>get_chisq()</code> is going to need several kinds of information.</p>
<ul>
<li>Our exponential failure function <code>f</code></li>
<li>Our parameters, eg. failure rate <code>lambda</code></li>
<li>Total number of parameters (if exponential, 1)</li>
<li>Our total number of units under test <code>n</code></li>
<li>Then, we’ll need a observed vector of times to failure <code>t</code>, plus a constant <code>binwidth</code> (previously, 5).</li>
<li>Or, if our data is pre-crosstabulated, we can ignore <code>t</code> and <code>binwidth</code> and just supply a DataFrame <code>data</code> of crosstabulated vectors <code>lower</code>, <code>upper</code>, and <code>r_obs</code>.</li>
</ul>
<p>For example, these inputs might look like this:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" tabindex="-1"></a><span class="co"># Get your &#39;model&#39; function</span></span>
<span id="cb69-2"><a href="#cb69-2" tabindex="-1"></a><span class="kw">def</span> f(t, lambda_val):</span>
<span id="cb69-3"><a href="#cb69-3" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span><span class="dv">1</span> <span class="op">*</span> lambda_val <span class="op">*</span> t)</span>
<span id="cb69-4"><a href="#cb69-4" tabindex="-1"></a><span class="co"># Parameters</span></span>
<span id="cb69-5"><a href="#cb69-5" tabindex="-1"></a><span class="co"># lambda = 1 / masks[&#39;left_earloop&#39;].mean()</span></span>
<span id="cb69-6"><a href="#cb69-6" tabindex="-1"></a><span class="co"># number of parameters</span></span>
<span id="cb69-7"><a href="#cb69-7" tabindex="-1"></a><span class="co"># np = 1</span></span>
<span id="cb69-8"><a href="#cb69-8" tabindex="-1"></a><span class="co"># total number of units (sometimes provided, if the data is time-censored)</span></span>
<span id="cb69-9"><a href="#cb69-9" tabindex="-1"></a><span class="co"># n_total = len(masks[&#39;left_earloop&#39;])</span></span>
<span id="cb69-10"><a href="#cb69-10" tabindex="-1"></a></span>
<span id="cb69-11"><a href="#cb69-11" tabindex="-1"></a><span class="co"># AND</span></span>
<span id="cb69-12"><a href="#cb69-12" tabindex="-1"></a></span>
<span id="cb69-13"><a href="#cb69-13" tabindex="-1"></a><span class="co"># Raw observed data + binwidth</span></span>
<span id="cb69-14"><a href="#cb69-14" tabindex="-1"></a><span class="co"># t = masks[&#39;left_earloop&#39;]</span></span>
<span id="cb69-15"><a href="#cb69-15" tabindex="-1"></a><span class="co"># binwidth = 5</span></span>
<span id="cb69-16"><a href="#cb69-16" tabindex="-1"></a><span class="co"># OR</span></span>
<span id="cb69-17"><a href="#cb69-17" tabindex="-1"></a><span class="co"># Crosstabulated data (c1 is an example we made before)</span></span>
<span id="cb69-18"><a href="#cb69-18" tabindex="-1"></a><span class="co"># data = c1[[&#39;lower&#39;, &#39;upper&#39;, &#39;r_obs&#39;]]</span></span></code></pre></div>
<p>Then, we could write out the function like this! I’ve added some docstring comments below just for notation, but you can simplify them if you prefer. This is a fairly complex function! I’ve shared it with you as an example to help you build your own for your projects.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" tabindex="-1"></a><span class="kw">def</span> get_chisq(t<span class="op">=</span><span class="va">None</span>, binwidth<span class="op">=</span><span class="dv">5</span>, data<span class="op">=</span><span class="va">None</span>, n_total<span class="op">=</span><span class="va">None</span>, f<span class="op">=</span><span class="va">None</span>, np<span class="op">=</span><span class="dv">1</span>, <span class="op">**</span>kwargs):</span>
<span id="cb70-2"><a href="#cb70-2" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb70-3"><a href="#cb70-3" tabindex="-1"></a><span class="co">    Function to Get Chi-Squared!</span></span>
<span id="cb70-4"><a href="#cb70-4" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb70-5"><a href="#cb70-5" tabindex="-1"></a><span class="co">    If observed vector...</span></span>
<span id="cb70-6"><a href="#cb70-6" tabindex="-1"></a><span class="co">    t: a vector of times to failure</span></span>
<span id="cb70-7"><a href="#cb70-7" tabindex="-1"></a><span class="co">    binwidth: size of intervals (eg. 5 hours) (Only if t is provided)</span></span>
<span id="cb70-8"><a href="#cb70-8" tabindex="-1"></a><span class="co">    If cross-tabulated data...</span></span>
<span id="cb70-9"><a href="#cb70-9" tabindex="-1"></a><span class="co">    data: a DataFrame with the vectors &#39;lower&#39;, &#39;upper&#39;, and &#39;r_obs&#39;</span></span>
<span id="cb70-10"><a href="#cb70-10" tabindex="-1"></a><span class="co">    Common Parameters:</span></span>
<span id="cb70-11"><a href="#cb70-11" tabindex="-1"></a><span class="co">    n_total: total number of units.</span></span>
<span id="cb70-12"><a href="#cb70-12" tabindex="-1"></a><span class="co">    f: specific failure function, such as f = f(t, lambda)</span></span>
<span id="cb70-13"><a href="#cb70-13" tabindex="-1"></a><span class="co">    np: total number of parameters in your function (eg. if exponential, 1 (lambda))</span></span>
<span id="cb70-14"><a href="#cb70-14" tabindex="-1"></a><span class="co">    **kwargs: fill in here any named parameters you need, like lambda=2.4 or rate=2.3 or mean=0, sd=2</span></span>
<span id="cb70-15"><a href="#cb70-15" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb70-16"><a href="#cb70-16" tabindex="-1"></a>    </span>
<span id="cb70-17"><a href="#cb70-17" tabindex="-1"></a>    <span class="co"># If vector `t` is NOT None</span></span>
<span id="cb70-18"><a href="#cb70-18" tabindex="-1"></a>    <span class="co"># Do the raw data route</span></span>
<span id="cb70-19"><a href="#cb70-19" tabindex="-1"></a>    <span class="cf">if</span> t <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb70-20"><a href="#cb70-20" tabindex="-1"></a>        <span class="co"># Make a DataFrame called &#39;tab&#39;</span></span>
<span id="cb70-21"><a href="#cb70-21" tabindex="-1"></a>        tab <span class="op">=</span> pd.DataFrame({<span class="st">&#39;t&#39;</span>: t})</span>
<span id="cb70-22"><a href="#cb70-22" tabindex="-1"></a>        <span class="co"># Part 1.1: Split into bins</span></span>
<span id="cb70-23"><a href="#cb70-23" tabindex="-1"></a>        tab[<span class="st">&#39;interval&#39;</span>] <span class="op">=</span> pd.cut(tab[<span class="st">&#39;t&#39;</span>], bins<span class="op">=</span><span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">int</span>(tab[<span class="st">&#39;t&#39;</span>].<span class="bu">max</span>()) <span class="op">+</span> binwidth <span class="op">+</span> <span class="dv">1</span>, binwidth))</span>
<span id="cb70-24"><a href="#cb70-24" tabindex="-1"></a>        <span class="co"># Part 1.2: Tally up observed failures &#39;r_obs&#39; by bin</span></span>
<span id="cb70-25"><a href="#cb70-25" tabindex="-1"></a>        tab <span class="op">=</span> tab.groupby(<span class="st">&#39;interval&#39;</span>, dropna<span class="op">=</span><span class="va">False</span>, observed<span class="op">=</span><span class="va">True</span>).size().reset_index(name<span class="op">=</span><span class="st">&#39;r_obs&#39;</span>)</span>
<span id="cb70-26"><a href="#cb70-26" tabindex="-1"></a>        tab <span class="op">=</span> tab.sort_values(<span class="st">&#39;interval&#39;</span>).reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb70-27"><a href="#cb70-27" tabindex="-1"></a>        tab[<span class="st">&#39;bin&#39;</span>] <span class="op">=</span> tab[<span class="st">&#39;interval&#39;</span>].cat.codes <span class="op">+</span> <span class="dv">1</span>  <span class="co"># R uses 1-based indexing</span></span>
<span id="cb70-28"><a href="#cb70-28" tabindex="-1"></a>        tab[<span class="st">&#39;lower&#39;</span>] <span class="op">=</span> (tab[<span class="st">&#39;bin&#39;</span>] <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> binwidth</span>
<span id="cb70-29"><a href="#cb70-29" tabindex="-1"></a>        tab[<span class="st">&#39;upper&#39;</span>] <span class="op">=</span> tab[<span class="st">&#39;bin&#39;</span>] <span class="op">*</span> binwidth</span>
<span id="cb70-30"><a href="#cb70-30" tabindex="-1"></a>        tab[<span class="st">&#39;midpoint&#39;</span>] <span class="op">=</span> (tab[<span class="st">&#39;lower&#39;</span>] <span class="op">+</span> tab[<span class="st">&#39;upper&#39;</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb70-31"><a href="#cb70-31" tabindex="-1"></a>        </span>
<span id="cb70-32"><a href="#cb70-32" tabindex="-1"></a>    <span class="co"># Otherwise, if DataFrame `data` is NOT None</span></span>
<span id="cb70-33"><a href="#cb70-33" tabindex="-1"></a>    <span class="co"># Do the cross-tabulated data route</span></span>
<span id="cb70-34"><a href="#cb70-34" tabindex="-1"></a>    <span class="cf">elif</span> data <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb70-35"><a href="#cb70-35" tabindex="-1"></a>        tab <span class="op">=</span> data.copy()</span>
<span id="cb70-36"><a href="#cb70-36" tabindex="-1"></a>        tab[<span class="st">&#39;bin&#39;</span>] <span class="op">=</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(tab) <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb70-37"><a href="#cb70-37" tabindex="-1"></a>        tab[<span class="st">&#39;midpoint&#39;</span>] <span class="op">=</span> (tab[<span class="st">&#39;lower&#39;</span>] <span class="op">+</span> tab[<span class="st">&#39;upper&#39;</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb70-38"><a href="#cb70-38" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb70-39"><a href="#cb70-39" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">&quot;Either &#39;t&#39; or &#39;data&#39; must be provided&quot;</span>)</span>
<span id="cb70-40"><a href="#cb70-40" tabindex="-1"></a>    </span>
<span id="cb70-41"><a href="#cb70-41" tabindex="-1"></a>    <span class="co"># Part 2. Calculate probabilities by interval</span></span>
<span id="cb70-42"><a href="#cb70-42" tabindex="-1"></a>    tab[<span class="st">&#39;p_upper&#39;</span>] <span class="op">=</span> f(tab[<span class="st">&#39;upper&#39;</span>], <span class="op">**</span>kwargs)</span>
<span id="cb70-43"><a href="#cb70-43" tabindex="-1"></a>    tab[<span class="st">&#39;p_lower&#39;</span>] <span class="op">=</span> f(tab[<span class="st">&#39;lower&#39;</span>], <span class="op">**</span>kwargs)</span>
<span id="cb70-44"><a href="#cb70-44" tabindex="-1"></a>    tab[<span class="st">&#39;p_fail&#39;</span>] <span class="op">=</span> tab[<span class="st">&#39;p_upper&#39;</span>] <span class="op">-</span> tab[<span class="st">&#39;p_lower&#39;</span>]</span>
<span id="cb70-45"><a href="#cb70-45" tabindex="-1"></a>    tab[<span class="st">&#39;n_total&#39;</span>] <span class="op">=</span> n_total</span>
<span id="cb70-46"><a href="#cb70-46" tabindex="-1"></a>    tab[<span class="st">&#39;r_exp&#39;</span>] <span class="op">=</span> tab[<span class="st">&#39;n_total&#39;</span>] <span class="op">*</span> tab[<span class="st">&#39;p_fail&#39;</span>]</span>
<span id="cb70-47"><a href="#cb70-47" tabindex="-1"></a>    </span>
<span id="cb70-48"><a href="#cb70-48" tabindex="-1"></a>    <span class="co"># Part 3-4: Calculate Chi-Squared statistic and p-value</span></span>
<span id="cb70-49"><a href="#cb70-49" tabindex="-1"></a>    chisq <span class="op">=</span> ((tab[<span class="st">&#39;r_obs&#39;</span>] <span class="op">-</span> tab[<span class="st">&#39;r_exp&#39;</span>])<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> tab[<span class="st">&#39;r_exp&#39;</span>]).<span class="bu">sum</span>()</span>
<span id="cb70-50"><a href="#cb70-50" tabindex="-1"></a>    nbin <span class="op">=</span> <span class="bu">len</span>(tab)</span>
<span id="cb70-51"><a href="#cb70-51" tabindex="-1"></a>    df <span class="op">=</span> nbin <span class="op">-</span> np <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb70-52"><a href="#cb70-52" tabindex="-1"></a>    p_value <span class="op">=</span> chi2.sf(x<span class="op">=</span>chisq, df<span class="op">=</span>df)</span>
<span id="cb70-53"><a href="#cb70-53" tabindex="-1"></a>    </span>
<span id="cb70-54"><a href="#cb70-54" tabindex="-1"></a>    output <span class="op">=</span> pd.DataFrame({</span>
<span id="cb70-55"><a href="#cb70-55" tabindex="-1"></a>        <span class="st">&#39;chisq&#39;</span>: [chisq],</span>
<span id="cb70-56"><a href="#cb70-56" tabindex="-1"></a>        <span class="st">&#39;nbin&#39;</span>: [nbin],</span>
<span id="cb70-57"><a href="#cb70-57" tabindex="-1"></a>        <span class="st">&#39;np&#39;</span>: [np],</span>
<span id="cb70-58"><a href="#cb70-58" tabindex="-1"></a>        <span class="st">&#39;df&#39;</span>: [df],</span>
<span id="cb70-59"><a href="#cb70-59" tabindex="-1"></a>        <span class="st">&#39;p_value&#39;</span>: [p_value]</span>
<span id="cb70-60"><a href="#cb70-60" tabindex="-1"></a>    })</span>
<span id="cb70-61"><a href="#cb70-61" tabindex="-1"></a>    </span>
<span id="cb70-62"><a href="#cb70-62" tabindex="-1"></a>    <span class="cf">return</span> output</span></code></pre></div>
<p>Finally, let’s try using our function!</p>
<p>Using a raw observed vector <code>t</code>:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" tabindex="-1"></a>get_chisq(</span>
<span id="cb71-2"><a href="#cb71-2" tabindex="-1"></a>    t<span class="op">=</span>masks[<span class="st">&#39;left_earloop&#39;</span>], binwidth<span class="op">=</span><span class="dv">5</span>, </span>
<span id="cb71-3"><a href="#cb71-3" tabindex="-1"></a>    n_total<span class="op">=</span><span class="dv">50</span>, f<span class="op">=</span>f, np<span class="op">=</span><span class="dv">1</span>, lambda_val<span class="op">=</span>mystat[<span class="st">&#39;lambda&#39;</span>].iloc[<span class="dv">0</span>])</span></code></pre></div>
<pre><code>##        chisq  nbin  np  df   p_value
## 0  13.317152     9   1   7  0.064748</code></pre>
<p>Or using crosstabulated <code>data</code>:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" tabindex="-1"></a>get_chisq(</span>
<span id="cb73-2"><a href="#cb73-2" tabindex="-1"></a>    data<span class="op">=</span>c1[[<span class="st">&#39;lower&#39;</span>, <span class="st">&#39;upper&#39;</span>, <span class="st">&#39;r_obs&#39;</span>]],</span>
<span id="cb73-3"><a href="#cb73-3" tabindex="-1"></a>    n_total<span class="op">=</span><span class="dv">50</span>, f<span class="op">=</span>f, np<span class="op">=</span><span class="dv">1</span>, lambda_val<span class="op">=</span>mystat[<span class="st">&#39;lambda&#39;</span>].iloc[<span class="dv">0</span>])</span></code></pre></div>
<pre><code>##        chisq  nbin  np  df   p_value
## 0  13.317152     9   1   7  0.064748</code></pre>
<p>Using <code>scipy.stats.expon.cdf</code> function instead of our homemade <code>f</code> function:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" tabindex="-1"></a><span class="kw">def</span> f_exp(t, rate):</span>
<span id="cb75-2"><a href="#cb75-2" tabindex="-1"></a>    <span class="cf">return</span> expon.cdf(t, scale<span class="op">=</span><span class="dv">1</span><span class="op">/</span>rate)</span>
<span id="cb75-3"><a href="#cb75-3" tabindex="-1"></a></span>
<span id="cb75-4"><a href="#cb75-4" tabindex="-1"></a>get_chisq(</span>
<span id="cb75-5"><a href="#cb75-5" tabindex="-1"></a>    data<span class="op">=</span>c1[[<span class="st">&#39;lower&#39;</span>, <span class="st">&#39;upper&#39;</span>, <span class="st">&#39;r_obs&#39;</span>]],</span>
<span id="cb75-6"><a href="#cb75-6" tabindex="-1"></a>    n_total<span class="op">=</span><span class="dv">50</span>, f<span class="op">=</span>f_exp, np<span class="op">=</span><span class="dv">1</span>, rate<span class="op">=</span>mystat[<span class="st">&#39;lambda&#39;</span>].iloc[<span class="dv">0</span>])</span></code></pre></div>
<pre><code>##        chisq  nbin  np  df   p_value
## 0  13.317152     9   1   7  0.064748</code></pre>
<p>Or using a different function that is not exponential!</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" tabindex="-1"></a><span class="kw">def</span> f_weibull(t, shape, scale):</span>
<span id="cb77-2"><a href="#cb77-2" tabindex="-1"></a>    <span class="cf">return</span> weibull_min.cdf(t, c<span class="op">=</span>shape, scale<span class="op">=</span>scale)</span>
<span id="cb77-3"><a href="#cb77-3" tabindex="-1"></a></span>
<span id="cb77-4"><a href="#cb77-4" tabindex="-1"></a>get_chisq(</span>
<span id="cb77-5"><a href="#cb77-5" tabindex="-1"></a>    data<span class="op">=</span>c1[[<span class="st">&#39;lower&#39;</span>, <span class="st">&#39;upper&#39;</span>, <span class="st">&#39;r_obs&#39;</span>]],</span>
<span id="cb77-6"><a href="#cb77-6" tabindex="-1"></a>    n_total<span class="op">=</span><span class="dv">50</span>, f<span class="op">=</span>f_weibull, np<span class="op">=</span><span class="dv">2</span>, shape<span class="op">=</span><span class="fl">0.2</span>, scale<span class="op">=</span><span class="fl">0.5</span>)</span></code></pre></div>
<pre><code>##         chisq  nbin  np  df       p_value
## 0  170.252819     9   2   6  3.975314e-34</code></pre>
<p><br>
<br></p>
<hr />
</div>
</div>
<div id="learning-check-4" class="section level2 unnumbered LC hasAnchor">
<h2>Learning Check 4<a href="#learning-check-4" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p><strong>Question</strong></p>
<p>A small start-up is product testing a new super-effective mask. They product tested 25 masks over 60 days. They contracted you to analyze the masks’ lifespan data, recorded below as the number of days to failure. If you were to make projections from this data, you’d want to be sure that you know the lifespan distribution of this data with confidence. Do these masks’ lifespan distribution fit an exponential distribution? Follow the steps below to find out.</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" tabindex="-1"></a><span class="co"># Lifespan in days</span></span>
<span id="cb79-2"><a href="#cb79-2" tabindex="-1"></a>supermasks <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">9</span>, <span class="dv">13</span>, <span class="dv">15</span>, <span class="dv">17</span>, <span class="dv">19</span>, </span>
<span id="cb79-3"><a href="#cb79-3" tabindex="-1"></a>            <span class="dv">20</span>, <span class="dv">21</span>, <span class="dv">23</span>, <span class="dv">24</span>, <span class="dv">24</span>, <span class="dv">24</span>, <span class="dv">32</span>, <span class="dv">33</span>, <span class="dv">33</span>, <span class="dv">34</span>, <span class="dv">54</span>]</span></code></pre></div>
<ol style="list-style-type: decimal">
<li><p>Cross-tabulate the lifespan distribution in intervals of <code>7 days</code>.</p></li>
<li><p>Estimate <span class="math inline">\(\hat{\lambda}\)</span> from the cross-tabulated data, knowing that they tested 25 masks over 60 days.</p></li>
<li><p><em>Using the cross-tabulated data</em>, do these masks’ lifespan distribution fit an exponential distribution, or does their distribution differ to a statistically significant degree from the exponential? How much? (eg. statistic and p-value).</p></li>
</ol>
<details>
<summary>
<strong>[View Answer!]</strong>
</summary>
<ol style="list-style-type: decimal">
<li>Cross-tabulate the lifespan distribution in intervals of <code>7 days</code>.</li>
</ol>
<div class="sourceCode" id="cb80"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" tabindex="-1"></a><span class="co"># Days to failure</span></span>
<span id="cb80-2"><a href="#cb80-2" tabindex="-1"></a>a <span class="op">=</span> pd.DataFrame({<span class="st">&#39;t&#39;</span>: supermasks})</span>
<span id="cb80-3"><a href="#cb80-3" tabindex="-1"></a><span class="co"># Step 1: Split into bins</span></span>
<span id="cb80-4"><a href="#cb80-4" tabindex="-1"></a>a[<span class="st">&#39;label&#39;</span>] <span class="op">=</span> pd.cut(a[<span class="st">&#39;t&#39;</span>], bins<span class="op">=</span><span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">int</span>(a[<span class="st">&#39;t&#39;</span>].<span class="bu">max</span>()) <span class="op">+</span> <span class="dv">8</span>, <span class="dv">7</span>))</span>
<span id="cb80-5"><a href="#cb80-5" tabindex="-1"></a><span class="co"># Step 2: Tally up by bin</span></span>
<span id="cb80-6"><a href="#cb80-6" tabindex="-1"></a>a <span class="op">=</span> a.groupby(<span class="st">&#39;label&#39;</span>, dropna<span class="op">=</span><span class="va">False</span>, observed<span class="op">=</span><span class="va">True</span>).size().reset_index(name<span class="op">=</span><span class="st">&#39;r_obs&#39;</span>)</span>
<span id="cb80-7"><a href="#cb80-7" tabindex="-1"></a>a <span class="op">=</span> a.sort_values(<span class="st">&#39;label&#39;</span>).reset_index(drop<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb80-8"><a href="#cb80-8" tabindex="-1"></a>a[<span class="st">&#39;bin&#39;</span>] <span class="op">=</span> a[<span class="st">&#39;label&#39;</span>].cat.codes <span class="op">+</span> <span class="dv">1</span>  <span class="co"># R uses 1-based indexing</span></span>
<span id="cb80-9"><a href="#cb80-9" tabindex="-1"></a>a[<span class="st">&#39;lower&#39;</span>] <span class="op">=</span> (a[<span class="st">&#39;bin&#39;</span>] <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> <span class="dv">7</span></span>
<span id="cb80-10"><a href="#cb80-10" tabindex="-1"></a>a[<span class="st">&#39;upper&#39;</span>] <span class="op">=</span> a[<span class="st">&#39;bin&#39;</span>] <span class="op">*</span> <span class="dv">7</span></span>
<span id="cb80-11"><a href="#cb80-11" tabindex="-1"></a>a[<span class="st">&#39;midpoint&#39;</span>] <span class="op">=</span> (a[<span class="st">&#39;lower&#39;</span>] <span class="op">+</span> a[<span class="st">&#39;upper&#39;</span>]) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb80-12"><a href="#cb80-12" tabindex="-1"></a>a</span></code></pre></div>
<pre><code>##       label  r_obs  bin  lower  upper  midpoint
## 0    (0, 7]      9    1      0      7       3.5
## 1   (7, 14]      2    2      7     14      10.5
## 2  (14, 21]      5    3     14     21      17.5
## 3  (21, 28]      4    4     21     28      24.5
## 4  (28, 35]      4    5     28     35      31.5
## 5  (49, 56]      1    8     49     56      52.5</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Estimate <span class="math inline">\(\hat{\lambda}\)</span> from the cross-tabulated data, knowing that they tested 25 masks over 60 days.</li>
</ol>
<div class="sourceCode" id="cb82"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" tabindex="-1"></a><span class="co"># Let&#39;s estimate lambda-hat!</span></span>
<span id="cb82-2"><a href="#cb82-2" tabindex="-1"></a>a[<span class="st">&#39;midpoint&#39;</span>] <span class="op">=</span> (a[<span class="st">&#39;upper&#39;</span>] <span class="op">-</span> a[<span class="st">&#39;lower&#39;</span>]) <span class="op">/</span> <span class="dv">2</span> <span class="op">+</span> a[<span class="st">&#39;lower&#39;</span>]</span>
<span id="cb82-3"><a href="#cb82-3" tabindex="-1"></a><span class="co"># Estimate lambda</span></span>
<span id="cb82-4"><a href="#cb82-4" tabindex="-1"></a>b <span class="op">=</span> pd.DataFrame({</span>
<span id="cb82-5"><a href="#cb82-5" tabindex="-1"></a>    <span class="st">&#39;r&#39;</span>: [a[<span class="st">&#39;r_obs&#39;</span>].<span class="bu">sum</span>()],  <span class="co"># total failures</span></span>
<span id="cb82-6"><a href="#cb82-6" tabindex="-1"></a>    <span class="st">&#39;days&#39;</span>: [(a[<span class="st">&#39;midpoint&#39;</span>] <span class="op">*</span> a[<span class="st">&#39;r_obs&#39;</span>]).<span class="bu">sum</span>()],  <span class="co"># total failure-days</span></span>
<span id="cb82-7"><a href="#cb82-7" tabindex="-1"></a>    <span class="st">&#39;n&#39;</span>: [a[<span class="st">&#39;r_obs&#39;</span>].<span class="bu">sum</span>()],  <span class="co"># in this case, total failures = total obs</span></span>
<span id="cb82-8"><a href="#cb82-8" tabindex="-1"></a>    <span class="st">&#39;tz&#39;</span>: [a[<span class="st">&#39;midpoint&#39;</span>].<span class="bu">max</span>()],  <span class="co"># end of study period</span></span>
<span id="cb82-9"><a href="#cb82-9" tabindex="-1"></a>})</span>
<span id="cb82-10"><a href="#cb82-10" tabindex="-1"></a><span class="co"># Calculate lambda hat!</span></span>
<span id="cb82-11"><a href="#cb82-11" tabindex="-1"></a>b[<span class="st">&#39;lambda_hat&#39;</span>] <span class="op">=</span> b[<span class="st">&#39;r&#39;</span>] <span class="op">/</span> (b[<span class="st">&#39;days&#39;</span>] <span class="op">+</span> (b[<span class="st">&#39;n&#39;</span>] <span class="op">-</span> b[<span class="st">&#39;r&#39;</span>]) <span class="op">*</span> b[<span class="st">&#39;tz&#39;</span>])</span>
<span id="cb82-12"><a href="#cb82-12" tabindex="-1"></a></span>
<span id="cb82-13"><a href="#cb82-13" tabindex="-1"></a><span class="co"># view it</span></span>
<span id="cb82-14"><a href="#cb82-14" tabindex="-1"></a>b</span></code></pre></div>
<pre><code>##     r   days   n    tz  lambda_hat
## 0  25  416.5  25  52.5    0.060024</code></pre>
<ol start="3" style="list-style-type: decimal">
<li><em>Using the cross-tabulated data</em>, do these masks’ lifespan distribution fit an exponential distribution, or does their distribution differ to a statistically significant degree from the exponential? How much? (eg. statistic and p-value).</li>
</ol>
<div class="sourceCode" id="cb84"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" tabindex="-1"></a><span class="co"># Get your &#39;model&#39; function</span></span>
<span id="cb84-2"><a href="#cb84-2" tabindex="-1"></a><span class="kw">def</span> f(t, lambda_val):</span>
<span id="cb84-3"><a href="#cb84-3" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span><span class="dv">1</span> <span class="op">*</span> lambda_val <span class="op">*</span> t)</span>
<span id="cb84-4"><a href="#cb84-4" tabindex="-1"></a><span class="co"># Get lambda-hat from b[&#39;lambda_hat&#39;].iloc[0]</span></span>
<span id="cb84-5"><a href="#cb84-5" tabindex="-1"></a></span>
<span id="cb84-6"><a href="#cb84-6" tabindex="-1"></a><span class="co"># Step 3a: Calculate Observed vs. Expected</span></span>
<span id="cb84-7"><a href="#cb84-7" tabindex="-1"></a>get_chisq(data<span class="op">=</span>a[[<span class="st">&#39;lower&#39;</span>, <span class="st">&#39;upper&#39;</span>, <span class="st">&#39;r_obs&#39;</span>]], n_total<span class="op">=</span><span class="dv">25</span>, np<span class="op">=</span><span class="dv">1</span>, f<span class="op">=</span>f, lambda_val<span class="op">=</span>b[<span class="st">&#39;lambda_hat&#39;</span>].iloc[<span class="dv">0</span>])</span></code></pre></div>
<pre><code>##       chisq  nbin  np  df   p_value
## 0  8.107232     6   1   4  0.087728</code></pre>
<div class="sourceCode" id="cb86"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" tabindex="-1"></a><span class="co"># Step 3b: Calculate Chi-squared if we had received the vector supermasks all along, assuming that were the whole population</span></span>
<span id="cb86-2"><a href="#cb86-2" tabindex="-1"></a><span class="co"># Get lambda from directly from the data</span></span>
<span id="cb86-3"><a href="#cb86-3" tabindex="-1"></a><span class="kw">def</span> f(t, lambda_val):</span>
<span id="cb86-4"><a href="#cb86-4" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span> <span class="op">-</span> np.exp(<span class="op">-</span><span class="dv">1</span> <span class="op">*</span> lambda_val <span class="op">*</span> t)</span>
<span id="cb86-5"><a href="#cb86-5" tabindex="-1"></a>get_chisq(t<span class="op">=</span>supermasks, binwidth<span class="op">=</span><span class="dv">7</span>,</span>
<span id="cb86-6"><a href="#cb86-6" tabindex="-1"></a>          n_total<span class="op">=</span><span class="dv">25</span>, np<span class="op">=</span><span class="dv">1</span>, f<span class="op">=</span>f, </span>
<span id="cb86-7"><a href="#cb86-7" tabindex="-1"></a>          lambda_val<span class="op">=</span><span class="dv">1</span> <span class="op">/</span> np.mean(supermasks))</span></code></pre></div>
<pre><code>##       chisq  nbin  np  df   p_value
## 0  7.956932     6   1   4  0.093169</code></pre>
<p>The slight difference in results is due to <code>b['lambda_hat']</code> being slightly different from <code>1 / np.mean(supermasks)</code>, the true empirical failure rate.</p>
</details>
<hr />
<p><br>
<br></p>
</div>
<div id="conclusion" class="section level2 hasAnchor" number="1.7">
<h2><span class="header-section-number">1.7</span> Conclusion<a href="#conclusion" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>All done! You’ve just picked up some powerful statistical techniques for estimating product lifespans in <code>Python</code>.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>


    </div>
  </div>
<script src="assets/gitbook-2.6.7/js/app.min.js"></script>
<script src="assets/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="assets/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="assets/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="assets/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="assets/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="assets/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="assets/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
  "sharing": {
    "github": false,
    "facebook": true,
    "twitter": true,
    "linkedin": false,
    "weibo": false,
    "instapaper": false,
    "vk": false,
    "whatsapp": false,
    "all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
  },
  "fontsettings": {
    "theme": "white",
    "family": "sans",
    "size": 2
  },
  "edit": {
    "link": null,
    "text": null
  },
  "history": {
    "link": null,
    "text": null
  },
  "view": {
    "link": null,
    "text": null
  },
  "download": null,
  "search": false,
  "toc": {
    "collapse": "subsection"
  },
  "toolbar": {
    "position": "static"
  }
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
